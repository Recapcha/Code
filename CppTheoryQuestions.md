
**Основные отличия типов данных float и double в C++**:

1. **Размер в байтах**. Для float он составляет 4 байта, а для double — 8 байт. Таким образом, double может хранить значения, которые в два раза больше, чем float. [1](https://www.freecodecamp.org/news/double-vs-float-in-cpp-the-difference-between-floats-and-doubles/)
2. **Точность**. [1](https://www.freecodecamp.org/news/double-vs-float-in-cpp-the-difference-between-floats-and-doubles/)[2](https://www.scaler.com/topics/difference-between-float-and-double-in-c-cpp/) float может точно хранить до 7 десятичных цифр, а double — до 15. [1](https://www.freecodecamp.org/news/double-vs-float-in-cpp-the-difference-between-floats-and-doubles/)
3. **Использование**. float чаще используется в графических библиотеках для высокой мощности обработки из-за своего небольшого диапазона. Double в основном применяется для расчётов в программировании, чтобы исключить ошибки при округлении десятичных значений. [1](https://www.freecodecamp.org/news/double-vs-float-in-cpp-the-difference-between-floats-and-doubles/)

Выбор между float и double зависит от требований приложения. Float используется, когда важна экономия памяти и достаточна скромная степень точности, например, в графике или симуляциях. Double предпочтительнее, когда нужна высокая точность и можно позволить себе использовать больше памяти. [2

---

`::` - Уточнённый идентификатор

_Уточнённый идентификатор_ 

Например, выражение `std::string::npos` является `id`-выражением, которое именует статический член `npos` класса `string` из пространства имён `std`. Выражение `::tolower` именует функцию `tolower` из глобального пространства имён. Выражение `::std::cout` именует глобальную переменную `cout` из пространства имён _верхнего уровня_ `std`. Уточнённый идентификатор `boost::signals2::connection` именует тип `connection`, принадлежащий пространству имён `signals2`, которое само находится в пространстве имён `boost`.

## *
---

Звездочка говорит вернуть переменную. Часто идет с %s которая говорит в какое место вернуть переменную 


```cpp
UE_LOG(LogBaseGeometry, Display, TEXT("Color to set up: %s"), *NewColor.ToString());
```

`*GetName`
Оператор * возвращается тип FString. Поэтому используется 

_*звёздочка (_) означает, что метод ToString() возвращает указатель(переменную), а не саму строку

## %s
---

Говорит о том где будет стоять переменная. 

%s - **знак «%s» означает, что при выводе лога нужно указать адрес строки, а не её значение**. 

Это специфика движка, для логов звёздочка необходима для работы и относится именно к строке. 

```cpp
UE_LOG(LogBaseGeometry, Display, TEXT("Color to set up: %s"), *NewColor.ToString());
```

## &
---
```cpp
void ABaseGeometryActor::SetColor(const FLinearColor& Color)
```

```cpp
FLinearColor& Color
```

Говорит о том что надо взять переменную из FLinearColor
 
FLinearColor& Color — это **тип данных для представления линейного цвета RGBA** в Unreal Engine. 

Bit
---

FLinearColor = 32bit
FColor = 8bit 

## <=
---
стандартное значение меньше или равно 
## ->
---
Создает каст до одной функции и из нее вытаскивает другую. Либо дает каст до объекта, что бы к нему потом применить что то. В любом случае это зависимость от первого объекта ко второму

`UMaterialInstanceDynamic* DynMaterial = BaseMesh->CreateAndSetMaterialInstanceDynamic(0);

Выражение 

`float time = GetWorld()->GetTimeSeconds()`

 **возвращает значение времени в секундах с момента запуска игры или сервера**


Различие между public/protected / private
Добавление А к АActor

### Различие между `public`, `protected`, `private` в C++
---


Эти модификаторы доступа используются для управления уровнем доступа к членам класса (переменным и методам). Разберем их:

1. **`public` (открытый доступ):**
    
    - Доступен из любого места программы.
    - Все классы и объекты могут использовать эти члены.
    
    **Пример:**
    
    cpp
    
    Копировать код
    
```cpp
    class Example {
public:
    int x; // доступен отовсюду
    void Print() { std::cout << "x = " << x; }
};
Example obj;
obj.x = 5; // доступ разрешен
obj.Print();

```
    
2. **`protected` (защищенный доступ):**
    
    - Доступен внутри класса и его потомков (наследников).
    - Полезно для реализации базового функционала, который нужен только наследникам.
    
    **Пример:**
    
    cpp
    
    Копировать код
    
```cpp
class Base {
protected:
    int value; // доступен для наследников
};
class Derived : public Base {
public:
    void SetValue(int val) { value = val; } // доступ разрешен
};

```
    
3. **`private` (закрытый доступ):**
    
    - Доступен только внутри класса, где объявлен.
    - Защищает данные от внешнего доступа.
    
    **Пример:**
    
    cpp
    
    Копировать код
    
```cpp
class Secret {
private:
    int key; // доступен только внутри класса
public:
    void SetKey(int k) { key = k; } // управление через публичные методы
};

```
    

### Для чего это нужно?

Модификаторы доступа помогают:

- **Инкапсулировать данные**, скрывая внутренние детали реализации.
- **Управлять доступом**, чтобы не допустить ошибок и нежелательного поведения.
- Делать код более **понятным** и **безопасным**.

## Почему private может лежать в public? 

---

В классе **private** члены определяют, что они доступны только изнутри самого класса. Однако, **public** секция может предоставлять доступ к этим членам через методы. Это концепция называется **инкапсуляцией**.

```cpp
class MyClass
{
private:
    int PrivateVariable;

public:
    int GetPrivateVariable() const { return PrivateVariable; }
    void SetPrivateVariable(int Value) { PrivateVariable = Value; }
};

```

Здесь `PrivateVariable` скрыт, но доступ к нему осуществляется через публичные геттеры и сеттеры.

### Что значит добавление `A` к `AActor`?
---

`A` перед названием класса (например, `AActor`) — это часть соглашения об именах, принятого в **Unreal Engine**.

- **A** указывает на то, что класс является **актером** (`Actor`) в игровом мире.
- Это соглашение помогает сразу понимать, с чем ты работаешь. Например:
    - Классы с префиксом `A` — **актеры**, которые могут быть размещены на сцене.
    - Классы с префиксом `U` — **объекты** (например, `UObject`), которые служат для логики или данных.

## Как и для чего использовать приписки static class?
---


```cpp
    DefaultPawnClass = STUBaseCharacter::StaticClass();
    PlayerControllerClass = ASTUPlayerController::StaticClass();
```

Метод **StaticClass** возвращает метаинформацию (UClass) о классе, что позволяет движку работать с типами динамически, например, создавать объекты или задавать настройки.

Пример использования:

```cpp
DefaultPawnClass = STUBaseCharacter::StaticClass();
```

- **DefaultPawnClass** указывает движку, что игрок по умолчанию будет использовать **STUBaseCharacter** как Pawn.
- **PlayerControllerClass** указывает класс, который будет использоваться как контроллер игрока.

### Где это нужно:

1. Задание классов по умолчанию (DefaultPawnClass, PlayerControllerClass, HUDClass и т.д.).
2. Создание объектов на основе метаинформации

```cpp
UObject* NewObject = NewObject<UObject>(GetWorld(), MyClass::StaticClass());
```
## CreateDefaultSubobject? 
---
**CreateDefaultSubobject** — это метод, используемый для создания компонентов (например, камеры, мешей) в классе **Actor** или его потомках. Эти компоненты являются частью иерархии объекта и управляются самим объектом.

```cpp
CameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT("CameraComponent"));
```

- **TEXT("CameraComponent")** — это имя компонента, видимое в редакторе Unreal Engine.
- Возвращает указатель на созданный объект.
## ->?
---

**->** — это оператор доступа к членам структуры или класса через указатель.  
Если у вас есть указатель на объект, вы используете **->**, чтобы обратиться к его методам или свойствам.

```cpp
   CameraComponent->SetupAttachment(GetRootComponent());
```

Здесь:

- **CameraComponent** — указатель на объект камеры.
- **SetupAttachment** — метод объекта, к которому мы обращаемся через указатель.

## Когда ставятся ()
---

Для вызова функции или метода:

```cpp
   CameraComponent->SetupAttachment(GetRootComponent());
```

Для конструкторов:
```
FVector Location(0.0f, 100.0f, 200.0f);
```

**() не ставятся** для свойств или переменных:

```cpp
float Health = MyCharacter->CurrentHealth;  // без ()
```
## Делегаты это?
---
**Делегаты** — это аналоги событий и функций-обработчиков в Unreal Engine. Они позволяют "подписываться" на определенные события или вызывать функции в ответ на события.

Пример:
``` cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnHealthChanged);

class MyCharacter : public AActor
{
public:
    FOnHealthChanged OnHealthChanged;
};

```

Использование:

```cpp
MyCharacter->OnHealthChanged.AddDynamic(this, &MyClass::OnHealthChangedHandler);
```

Здесь метод **OnHealthChangedHandler** будет вызываться, когда делегат **OnHealthChanged** вызван через `Broadcast()`.

## Что такое broadcast?
---

**Broadcast** — это метод, который используется в Unreal Engine для вызова всех функций, подписанных на делегат. По сути, он "рассылает" событие всем подписчикам.

```cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnHealthChanged);

class MyCharacter : public AActor
{
public:
    FOnHealthChanged OnHealthChanged;
    
    void TakeDamage(float Damage)
    {
        Health -= Damage;
        OnHealthChanged.Broadcast();  // Уведомляем подписчиков о событии
    }
};

```

Если у вас есть подписчики на делегат **OnHealthChanged**, вызов **Broadcast()** автоматически вызовет их функции.

Подписка на делегат:

```cpp
MyCharacter->OnHealthChanged.AddDynamic(this, &MyClass::OnHealthChangedHandler);
```

Обработчик:

```cpp
void MyClass::OnHealthChangedHandler()
{
    UE_LOG(LogTemp, Warning, TEXT("Health has changed!"));
}
```

## SUPER это?
---

**SUPER** — это макрос, используемый для обращения к базовому классу. Он упрощает вызов методов предка.  
Пример:

```Cpp
void AMyClass::BeginPlay()
{
    Super::BeginPlay();  // Вызывает BeginPlay() из базового класса
    // Ваш код
}
```

Это важно, чтобы гарантировать, что логика предка выполнится, прежде чем добавляется дополнительная логика в наследнике.

## Когда ставят ;
---

В C++ точка с запятой используется для завершения объявления или определения, за исключением некоторых ситуаций.

#### Примеры:

- **Объявления переменных и методов:**

```cpp
int MyVariable; // Объявление переменной
void MyFunction(); // Объявление функции
```

После классов и структур:

```cpp
class MyClass
{
    // Члены класса
};  // Обязательно ставим `;`
```

В конце каждой инструкции:

```cpp
int a = 10; // Завершение инструкции
a += 5;     // Завершение инструкции
```

#### Когда `;` **не ставится:**

1. **После определения функций:**

```cpp
void MyFunction()
{
    // Код функции
}  // Тут `;` не ставится
```

После условных операторов или циклов (но `;` может быть внутри них):

```cpp
if (a > 0)
{
    // Код
}  // Нет `;` после фигурных скобок
```

После макросов:

``` cpp
#define MY_MACRO 10  // Без `;`
```

### Особый случай: "лишняя" точка с запятой

**Пустая инструкция**:

Она ничего не делает, но иногда используется для пустых циклов:

```cpp
while (SomeCondition)
    ;  // Пустой цикл
```
## Что такое макрос?
---

Макрос в C++ — это инструкция препроцессору, которая заменяет код перед компиляцией. Макросы определяются с помощью директивы `#define` и позволяют вставлять текстовые подстановки или создавать шаблоны кода.

Пример макроса:

```cpp
#define PI 3.14159  // Макрос для константы
#define SQUARE(x) ((x) * (x))  // Макрос-функция
```

Использование:

```cpp
float Area = PI * SQUARE(5);
```

После препроцессинга код заменится на:

```cpp
float Area = 3.14159 * ((5) * (5));
```

#### Особенности макросов:

- Макросы выполняются **до компиляции**.
- Они не проверяются на типы (в отличие от функций и классов).
- Могут усложнять отладку из-за подстановки кода.

## Инструкция - это 
---
**Инструкция** — это любая единица кода, которая выполняет действие. Это может быть:

Объявление переменной

```cpp
int x = 10;  // Инструкция
```

Вызов функции:

```cpp
PrintHello();  // Инструкция
```

Оператор (например, присваивание или цикл):

```cpp
x += 5;  // Инструкция
```

Условие

```cpp
if (x > 10) { ... }  // Инструкция
```

Таким образом, объявление переменной — это **частный случай инструкции**.
## Различие функции и класс и макросов?
---

![[Pasted image 20241219013834.png]]

#### Когда использовать:

- **Функции**: когда нужен конкретный алгоритм.
- **Классы**: для описания сложных объектов и их взаимодействия.
- **Макросы**: для простых констант, условной компиляции или шаблонов.

## Зачем может существовать пустой цикл?
---

Пустой цикл используется в случаях, когда выполняется действие без явного тела цикла. Такие циклы могут быть полезны для:

Ожидания (wait loop)**:  
Ожидание завершения какого-либо события или состояния.

```cpp
while (!DataReady)
    ;  // Ничего не делаем, просто ждем
```

**Поиск значения:**  
Вы можете выполнить определённое вычисление в условии или инкременте.

```cpp
int i = 0;
while (Array[i++] != TargetValue)
    ;  // Пустое тело
```

**Синхронизация:**  
Например, для потоков:

```cpp
while (!ThreadSafeFlag)
    ;  // Ждем, пока поток установит флаг
```

**Индексация:**  
Когда нужно только выполнить вычисление:

```cpp
for (int i = 0; i < 10; i++)
    ;  // Просто инкрементируем i
```

#### Важное замечание:

Пустые циклы могут быть **неэффективными**. Если возможно, лучше использовать более подходящие методы (например,  для ожидания).

```cpp
`std::this_thread::sleep_for` 
```

## FTransform
---

В Unreal Engine, **FTransform** — это структура, которая описывает преобразование объекта в 3D-пространстве. Она объединяет три ключевых компонента:

1. **Трансляция (Translation)** — отвечает за позицию объекта.
2. **Ротация (Rotation)** — описывает ориентацию объекта.
3. **Масштабирование (Scale)** — определяет размер объекта.

**FTransform** используется для работы с положением, поворотом и масштабом объектов, таких как акторы, компоненты, камеры и так далее. Это более компактная и производительная альтернатива матрицам преобразований (FMatrix).

```cpp
const FTransform GeometryTransform = FTransform(FRotator::ZeroRotator, FVector(0.0f, 300.0f * i, 300.0f));
```

### Расшифровка:

1. **`FTransform`**  
    Создается новая трансформация (положение, поворот, масштаб). Конструктор принимает три параметра:
    - Ротацию (**FRotator**),
    - Трансляцию (**FVector**),
    - Масштаб (**FVector**, необязательный, по умолчанию равен (1, 1, 1)).

## Что такое указатель на объект?
---

**Указатель на объект** — это переменная, которая хранит **адрес в памяти** объекта (или переменной) в программе. В C++ указатель позволяет вам работать с объектами в динамической памяти, обращаться к ним и изменять их данные. Вместо того чтобы копировать сами данные объекта, указатель предоставляет доступ к объекту по его адресу в памяти.

### Основные моменты о указателях на объекты:

1. **Адрес объекта**: Указатель хранит адрес, по которому находится объект в памяти, а не сам объект. Это позволяет работать с объектом, не создавая его копию.
    
2. **Тип указателя**: Указатель должен иметь тип, соответствующий типу объекта, на который он ссылается. Например, если у вас есть объект типа `AActor`, то указатель на этот объект будет иметь тип `AActor*`.
    
3. **Использование указателя**: Указатели позволяют вам:
    
    - Получать доступ к членам объекта.
    - Изменять свойства объекта, если это необходимо.
    - Передавать объекты в функции, не копируя их (что может быть дорогим процессом, особенно для крупных объектов).

### Пример указателя на объект:

Допустим, у вас есть класс `Person`, и вы хотите создать объект этого класса и использовать указатель на него:

```cpp
class Person
{
public:
    void Greet()
    {
        std::cout << "Hello, I am a person!" << std::endl;
    }
};

int main()
{
    // Создаем объект класса Person
    Person person;

    // Создаем указатель на объект Person
    Person* pointer = &person;

    // Используем указатель для вызова метода объекта
    pointer->Greet();  // Вызовет method Greet() объекта person
}

```

### Детальное объяснение:

1. **Создание объекта:**

```cpp
Person person;
```

- Это создаёт объект `person` типа `Person` в стеке.
    
- **Создание указателя на объект:**

```cpp
Person* pointer = &person;
```

- Указатель `pointer` хранит адрес объекта `person`. Оператор `&` используется для получения адреса переменной.
    
- **Доступ к членам объекта через указатель:**

```cpp
pointer->Greet();
```

Для доступа к членам объекта через указатель используется оператор `->`. Это аналогично тому, как мы бы использовали точку `.` для доступа к членам объекта (например, `person.Greet()`), но в случае с указателем мы используем `->`, чтобы указать на объект через его адрес в памяти.
### Почему указатели полезны?

1. **Эффективность**: Вместо того чтобы передавать объект целиком в функцию, можно передать указатель на объект, тем самым избегая затрат на копирование данных.
    
2. **Динамическая память**: Указатели позволяют работать с объектами, которые создаются динамически в куче (с помощью оператора `new`), а не в стеке. Это важно, когда объекты имеют переменный размер или срок жизни.
    
3. **Изменение объектов в функциях**: Указатели позволяют изменять содержимое объектов внутри функций, передавая их по ссылке через указатели. Если бы мы передавали объект по значению, то изменения касались бы только копии объекта, а не исходного.
    
### Пример с динамическим выделением памяти:

```cpp
class Person
{
public:
    std::string name;
    Person(std::string name) : name(name) {}
    void Greet() { std::cout << "Hello, I am " << name << "!" << std::endl; }
};

int main()
{
    // Создаем объект в динамической памяти (в куче)
    Person* pPerson = new Person("John");

    // Используем указатель для вызова метода
    pPerson->Greet();

    // Освобождаем память
    delete pPerson;
}
```

### Важные моменты:

1. **Доступ через указатель**:
    - `pointer->Greet()` — это эквивалент `(*pointer).Greet()`. Оба способа дают доступ к методу объекта через указатель.
2. **Удаление объекта**:
    - Когда вы создаёте объект с помощью `new`, важно освободить память с помощью `delete`, чтобы избежать утечек памяти.

### Сводка:

- Указатель на объект — это переменная, которая хранит **адрес объекта** в памяти, а не сам объект.
- Указатели используются для более эффективного доступа к объектам, передачи их в функции и работы с динамическими объектами.
- В C++ важно правильно управлять памятью, особенно при использовании указателей, чтобы избежать утечек памяти.

## Что такое функция и какие бывают?
---

int main() void main1() это две функции? тогда почему у одного пишется void у другого int? зачем

Да, `int main()` и `void main1()` — это две разные функции, и различие между ними заключается в **типе возвращаемого значения**.

### Разница между `int main()` и `void main1()`:

`int main()`**
    - Это стандартная функция входа в программу в C++ (и в других языках программирования, таких как C).
    - Тип `int` означает, что функция `main` должна **возвращать целочисленное значение** в операционную систему по завершении работы программы.
    - Возвращаемое значение обычно используется для **индикации успешности выполнения программы**:
        - **0**: Программа завершилась успешно.
        - **Не 0**: Программа завершилась с ошибкой или ненормально

**`void main1()`**

- Это просто функция, которая называется `main1` (имя функции может быть любым, это не обязательно "main").
- Тип `void` означает, что эта функция **не возвращает никакого значения**. Она просто выполняет какой-то код, но не сообщает о своем результате (или о каких-то ошибках) через возвращаемое значение.
- Обычно функции с типом `void` используются в тех случаях, когда функция выполняет действия, но не требуется передавать какой-либо результат обратно.

**Функция** в программировании — это блок кода, предназначенный для выполнения определённой задачи. Функции позволяют группировать код, чтобы его можно было вызывать многократно с разными аргументами. Это упрощает структуру программы и повышает её читаемость и переиспользуемость. Функция может **принимать аргументы** (входные данные), выполнять операции с ними и **возвращать результат** (выходные данные).

### **Функции без возвращаемого значения (void)**

Если функция не должна ничего возвращать, то используется тип `void`.

```cpp
void greet() {
    std::cout << "Hello, World!" << std::endl;
}
```

В этом случае, функция `greet` не возвращает ничего (т.е. не имеет возвращаемого значения), она просто выполняет вывод текста на экран.

### **Функции с параметрами**

Функция может принимать аргументы (параметры), которые она будет использовать внутри своего тела.

```Cpp
int multiply(int a, int b) {
    return a * b;
}
```

Здесь функция `multiply` принимает два параметра типа `int` и возвращает их произведение.

### **Функции с несколькими возвращаемыми значениями**

В C++ нельзя вернуть несколько значений напрямую из функции, но можно использовать структуры или кортежи для этого.

Пример с использованием структуры:

```cpp
struct Result {
    int sum;
    int product;
};

Result calculate(int a, int b) {
    Result res;
    res.sum = a + b;
    res.product = a * b;
    return res;
}
```

### **Функции с значениями по умолчанию (default arguments)**

Можно задать значения по умолчанию для параметров, которые будут использоваться, если аргумент не передан при вызове функции.

```cpp
void printMessage(std::string message = "Hello, World!") {
    std::cout << message << std::endl;
}
```

Здесь, если не передан аргумент, будет выведено сообщение по умолчанию.
### **Перегрузка функций (Function Overloading)**

В C++ функции можно перегружать, то есть создавать несколько функций с одинаковым именем, но с разными типами или количеством параметров.

```cpp
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}
```

В этом примере функции `add` имеют одно и то же имя, но различаются типами принимаемых параметров.

### **Функции с указателями и ссылками (Pass by Pointer/Reference)**

Можно передавать аргументы функции через указатели или ссылки, чтобы изменить значения переданных переменных.

```cpp
void changeValue(int &x) {
    x = 10;
}

int main() {
    int a = 5;
    changeValue(a);  // Значение a изменится на 10
}
```

Здесь, благодаря использованию ссылки `&`, функция изменяет значение переменной `a`.

### **Функции с возвращением ссылок или указателей**

Функция может возвращать ссылку или указатель, а не просто значение.

```cpp
int& getElement(int* arr, int index) {
    return arr[index];
}
```

В этом примере возвращается ссылка на элемент массива. Это позволяет модифицировать элемент массива в месте его вызова.

### **Функции с переменным количеством аргументов (Varargs)**

C++ поддерживает функции с переменным количеством аргументов, с помощью таких механизмов, как `std::va_list` или более удобных вариантов, например, `std::initializer_list`.

```cpp
void printNumbers(std::initializer_list<int> numbers) {
    for (int num : numbers) {
        std::cout << num << " ";
    }
}
```

```cpp
printNumbers({1, 2, 3, 4, 5});
```

### **Lambda-функции**

Лямбда-функции — это анонимные функции, которые можно объявлять прямо внутри других функций. Они полезны для обработки данных в таких конструкциях, как `std::for_each` или при передаче в другие функции.

```cpp
auto sum = [](int a, int b) {
    return a + b;
};

int result = sum(3, 5);
```
### Резюме:

Функции в C++ могут быть объявлены разными способами, в зависимости от того, что они делают и какие данные обрабатывают. Это может быть:

- Функции с различными типами возвращаемых значений (например, `int`, `void`, структуры).
- Функции с аргументами и значениями по умолчанию.
- Перегрузка функций и работа с указателями, ссылками, и даже лямбда-функциями.

Функции являются важной частью программы, позволяя разбивать код на логические блоки и повышать читаемость и повторное использование кода.

## Что такое UFUNCTION? Как его вызвать?
---

## ?
---

```cpp
    return CrossProduct.IsZero() ?  Degrees : Degrees * FMath::Sign(CrossProduct.Z);
```

## if
---

```cpp
    if (Amount == 0.0f) return;
```

## const модификатор 
---

