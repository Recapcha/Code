
alt + t hot key 

>    - [[CppAbstract#Полезные ссылки|Полезные ссылки]]
>    - [[CppAbstract#Вступление |Вступление ]]
>    - [[CppAbstract#using namespace std |using namespace std ]]
>    - [[CppAbstract#Comment |Comment ]]
>    - [[CppAbstract#Библиотеки |Библиотеки ]]
>    - [[CppAbstract#Escape последовательности |Escape последовательности ]]
>    - [[CppAbstract#Типы данных |Типы данных ]]
>    - [[CppAbstract#Переменные |Переменные ]]
>    - [[CppAbstract#Константы |Константы ]]
>    - [[CppAbstract#Ввод данных |Ввод данных ]]
>    - [[CppAbstract#Операторы. Арифметические действия с числами |Операторы. Арифметические действия с числами ]]
>    - [[CppAbstract#Инкремент и декремент. Постфиксный и префиксный |Инкремент и декремент. Постфиксный и префиксный ]]
>    - [[CppAbstract#Сокращенные арифметические формы +=, -= и тд |Сокращенные арифметические формы +=, -= и тд ]]
>    - [[CppAbstract#Операторы сранвения, равенства, логические |Операторы сранвения, равенства, логические ]]
>    - [[CppAbstract#if / else |if / else ]]
>    - [[CppAbstract#Switch |Switch ]]
>    - [[CppAbstract#While |While ]]
>    - [[CppAbstract#Do While |Do While ]]
>    - [[CppAbstract#For |For ]]
>    - [[CppAbstract#Break, ключевое слово |Break, ключевое слово ]]
>    - [[CppAbstract#Continue |Continue ]]
>    - [[CppAbstract#Где лежит .exe |Где лежит .exe ]]
>    - [[CppAbstract#GOTO |GOTO ]]
>    - [[CppAbstract#Отладчик |Отладчик ]]
>    - [[CppAbstract#Вложенный цикл |Вложенный цикл ]]
>    - [[CppAbstract#Массив |Массив ]]
>    - [[CppAbstract#Инициализация массива |Инициализация массива ]]
>    - [[CppAbstract#Вывод массива. Заполнение |Вывод массива. Заполнение ]]
>    - [[CppAbstract#sizeof |sizeof ]]
>    - [[CppAbstract#rand. srand. rand задать диапазон. srand time null. Генератор случайных чисел. randomize |rand. srand. rand задать диапазон. srand time null. Генератор случайных чисел. randomize ]]
>    - [[CppAbstract#Двумерный массив |Двумерный массив ]]
>    - [[CppAbstract#Трехмерный массив |Трехмерный массив ]]
>    - [[CppAbstract#Двумерный массив. Инициализация. Индексы |Двумерный массив. Инициализация. Индексы ]]
>    - [[CppAbstract#Двумерные массив. Вывод. Заполнение |Двумерные массив. Вывод. Заполнение ]]
>    - [[CppAbstract#Функции.  Синтаксис. Объявление, реализация функции. Параметры, аргументы. |Функции.  Синтаксис. Объявление, реализация функции. Параметры, аргументы. ]]
>    - [[CppAbstract#Передача параметров в функцию по значению. Параметры функции. Передача аргументов.|Передача параметров в функцию по значению. Параметры функции. Передача аргументов.]]
>    - [[CppAbstract#Передать в функцию массив|Передать в функцию массив]]
>    - [[CppAbstract#Прототипы функции |Прототипы функции ]]
>    - [[CppAbstract#Область видимости. |Область видимости. ]]
>    - [[CppAbstract#Глобальные и локальные переменные. |Глобальные и локальные переменные. ]]
>    - [[CppAbstract#Аргументы или параметры по умолчанию |Аргументы или параметры по умолчанию ]]
>    - [[CppAbstract#Inline. Ключевое слово. Встраиваемая функция|Inline. Ключевое слово. Встраиваемая функция]]
>    - [[CppAbstract#Перегрузка функции. Как ее вызвать|Перегрузка функции. Как ее вызвать]]
>    - [[CppAbstract#Шаблонные функции |Шаблонные функции ]]
>    - [[CppAbstract#Функции и стек. Стек алгоритмов. Стек рекурсии. |Функции и стек. Стек алгоритмов. Стек рекурсии. ]]
>    - [[CppAbstract#Рекурсия. Рекурсия программирования. Рекурсия и цикл. |Рекурсия. Рекурсия программирования. Рекурсия и цикл. ]]
>    - [[CppAbstract#Рекурсия. Факториал числа. Рекурсия факториала. |Рекурсия. Факториал числа. Рекурсия факториала. ]]
>    - [[CppAbstract#Динамическая память. Утечка памяти. Стек и куча. Статическая память. |Динамическая память. Утечка памяти. Стек и куча. Статическая память. ]]
>    - [[CppAbstract#Указатели. |Указатели. ]]
>    - [[CppAbstract#Арифметика указателей. Указатели и массивы. Массив это указатель. |Арифметика указателей. Указатели и массивы. Массив это указатель. ]]
>    - [[CppAbstract#Передача параметров в функцию по указателю |Передача параметров в функцию по указателю ]]
>    - [[CppAbstract#Возврат нескольких значений функция через указатели. Функция возвращает несколько значений. |Возврат нескольких значений функция через указатели. Функция возвращает несколько значений. ]]
>    - [[CppAbstract#Ссылки |Ссылки ]]
>    - [[CppAbstract#Передача параметров в функцию по ссылке. Разница между ссылкой и указателем |Передача параметров в функцию по ссылке. Разница между ссылкой и указателем ]]
>    - [[CppAbstract#Возврат нескольких значений функций через ссылки|Возврат нескольких значений функций через ссылки]]
>    - [[CppAbstract#New C++. Что это пример. C++ new delete. |New C++. Что это пример. C++ new delete. ]]
>    - [[CppAbstract#Null pointer. nullptr. null|Null pointer. nullptr. null]]
>    - [[CppAbstract#Динамический массив. Создание, заполнение, удаление, размер динамического массива |Динамический массив. Создание, заполнение, удаление, размер динамического массива ]]
>    - [[CppAbstract#Двумерный динамический массив. Создание, заполнение, удаление. |Двумерный динамический массив. Создание, заполнение, удаление. ]]
>    - [[CppAbstract#Константные аргументы функции. Константный указатель. |Константные аргументы функции. Константный указатель. ]]
>    - [[CppAbstract#Как скопировать динамический массив |Как скопировать динамический массив ]]
>    - [[CppAbstract#Изменить размер массива. Удалить, добавить элемент в массив. Увеличение массива |Изменить размер массива. Удалить, добавить элемент в массив. Увеличение массива ]]
>    - [[CppAbstract#Строки. Нуль терминатор. Char |Строки. Нуль терминатор. Char ]]
>    - [[CppAbstract#Приведение типов в стиле с. Явное и неявное представление типов. Преобразование типов|Приведение типов в стиле с. Явное и неявное представление типов. Преобразование типов]]
>    - [[CppAbstract#Что такое ASCII символы. "аски"|Что такое ASCII символы. "аски"]]
>    - [[CppAbstract#Указатели символьные строки и функции. Строки и указатели |Указатели символьные строки и функции. Строки и указатели ]]
>    - [[CppAbstract#Конкотенация строк. Объединение строк. Тип данных string c++|Конкотенация строк. Объединение строк. Тип данных string c++]]
>    - [[CppAbstract#Указатель на функцию в качестве параметра |Указатель на функцию в качестве параметра ]]
>    - [[CppAbstract#Препроцессор. Директива #define. Макросы |Препроцессор. Директива #define. Макросы ]]
>    - [[CppAbstract#Макрос функции. Макросы с аргументами. Макросы с параметрами |Макрос функции. Макросы с аргументами. Макросы с параметрами ]]
>    - [[CppAbstract#Условная компиляция. Директивы #ifdef #else #endif #if #elif #endif #ifdef |Условная компиляция. Директивы #ifdef #else #endif #if #elif #endif #ifdef ]]
>    - [[CppAbstract#Условный тернарный оператор. |Условный тернарный оператор. ]]
>    - [[CppAbstract#Argc, Argv. Параметры функции |Argc, Argv. Параметры функции ]]
>    - [[CppAbstract#Int main или void main|Int main или void main]]
>    - [[CppAbstract#Что такое ООП|Что такое ООП]]
>    - [[CppAbstract#Что такое класс. Что такое объект класса. Экземпляр класса. |Что такое класс. Что такое объект класса. Экземпляр класса. ]]
>    - [[CppAbstract#Метода класса. Вызов метода класса. |Метода класса. Вызов метода класса. ]]
>    - [[CppAbstract#Модификаторы доступа классов. Public . Private . Protected . Спецификаторы доступа |Модификаторы доступа классов. Public . Private . Protected . Спецификаторы доступа ]]
>    - [[CppAbstract#Геттеры и сеттеры. Методы Get / Set . Инкапсуляция это |Геттеры и сеттеры. Методы Get / Set . Инкапсуляция это ]]
>    - [[CppAbstract#Инкапсуляция ООП пример. Private методы|Инкапсуляция ООП пример. Private методы]]
>    - [[CppAbstract#Конструктор класса в ООП. Конструктор с параметрами. Конструктор умолчанию. |Конструктор класса в ООП. Конструктор с параметрами. Конструктор умолчанию. ]]
>    - [[CppAbstract#Перегрузка конструктора класса|Перегрузка конструктора класса]]
>    - [[CppAbstract#Деструктор. Деструктор по умолчанию |Деструктор. Деструктор по умолчанию ]]
>    - [[CppAbstract#Ключевое слово this|Ключевое слово this]]
>    - [[CppAbstract#Конструктор копирования. Когда вызывается. Копирование объектов по умолчанию. |Конструктор копирования. Когда вызывается. Копирование объектов по умолчанию. ]]
>    - [[CppAbstract#Перегрузка операторов присваивания. ООП. а.оператор = |Перегрузка операторов присваивания. ООП. а.оператор = ]]
>    - [[CppAbstract#Перегрузка оператора равенства. == и не равно !=. Перегрузка логических операторов сравнения|Перегрузка оператора равенства. == и не равно !=. Перегрузка логических операторов сравнения]]
>    - [[CppAbstract#Свой класс String|Свой класс String]]
>    - [[CppAbstract#Свой класс string |Свой класс string ]]
>    - [[CppAbstract#Перегрузка операторов сложения|Перегрузка операторов сложения]]
>    - [[CppAbstract#Перегрузка оператора инкремента и декремента |Перегрузка оператора инкремента и декремента ]]
>    - [[CppAbstract#Перегрузка оператора индексирования |Перегрузка оператора индексирования ]]
>    - [[CppAbstract#Дружественные функции и классы |Дружественные функции и классы ]]
>    - [[CppAbstract#Определение методов вне класса. Вынести функцию из класса. Вынести описание метода  из класса |Определение методов вне класса. Вынести функцию из класса. Вынести описание метода  из класса ]]
>    - [[CppAbstract#Дружественный метод класса. Friend c++ Функции друзья. Переопределение методов |Дружественный метод класса. Friend c++ Функции друзья. Переопределение методов ]]
>    - [[CppAbstract#Переопределение методов. Определение переменной после ее включение. identifier uses undefined class after including|Переопределение методов. Определение переменной после ее включение. identifier uses undefined class after including]]
>    - [[CppAbstract#IntelliSense . Пересобрать решение|IntelliSense . Пересобрать решение]]
>    - [[CppAbstract#Дружественные классы. ООП. friend class c++ |Дружественные классы. ООП. friend class c++ ]]
>    - [[CppAbstract#Ключевое слово static. Статические поля класса. |Ключевое слово static. Статические поля класса. ]]
>    - [[CppAbstract#Статические методы класса. Модификатор static. |Статические методы класса. Модификатор static. ]]
>    - [[CppAbstract#Вложенные классы. Внутренние классы. Inner Class |Вложенные классы. Внутренние классы. Inner Class ]]
>    - [[CppAbstract#Массив объектов класса. Динамический. Статический. Создание особенности|Массив объектов класса. Динамический. Статический. Создание особенности]]
>    - [[CppAbstract#Что такое агрегация и композиция |Что такое агрегация и композиция ]]
>    - [[CppAbstract#Наследование в ООП. Что такое наследование. Для чего нужно наследование|Наследование в ООП. Что такое наследование. Для чего нужно наследование]]
>    - [[CppAbstract#Модификаторы доступа при наследовании. Private, public, Protected |Модификаторы доступа при наследовании. Private, public, Protected ]]
>    - [[CppAbstract#Порядок вызова конструкторов при наследовании. Как вызываются конструкторы |Порядок вызова конструкторов при наследовании. Как вызываются конструкторы ]]
>    - [[CppAbstract#Порядок вызова деструктора при наследовании. Деструкторы. |Порядок вызова деструктора при наследовании. Деструкторы. ]]
>    - [[CppAbstract#Вызов конструктора базового класса из конструктора класса-наследника. Наследование |Вызов конструктора базового класса из конструктора класса-наследника. Наследование ]]
>    - [[CppAbstract#Виртуальные методы класса C++. Ключевое слово virtual. Ключевое слово override|Виртуальные методы класса C++. Ключевое слово virtual. Ключевое слово override]]
>    - [[CppAbstract#Абстрактный класс. Чисто виртуальная функция. virtual override. Полиморфизм |Абстрактный класс. Чисто виртуальная функция. virtual override. Полиморфизм ]]
>    - [[CppAbstract#Виртуальный деструктор  |Виртуальный деструктор  ]]
>    - [[CppAbstract#Чисто виртуальный деструктор |Чисто виртуальный деструктор ]]
>    - [[CppAbstract#Делегирующие конструкторы |Делегирующие конструкторы ]]
>    - [[CppAbstract#Вызов виртуального метода базового класса |Вызов виртуального метода базового класса ]]
>    - [[CppAbstract#Множественное наследование |Множественное наследование ]]
>    - [[CppAbstract#Порядок вызова конструкторов при множественном наследовании |Порядок вызова конструкторов при множественном наследовании ]]
>    - [[CppAbstract#Порядок вызова деструкторов при множественном наследовании |Порядок вызова деструкторов при множественном наследовании ]]
>    - [[CppAbstract#Ошибки в программировании |Ошибки в программировании ]]
>        - [[CppAbstract#Ошибки на этапе компиляции - |Ошибки на этапе компиляции - ]]
>        - [[CppAbstract#Ошибка во время выполнения или ошибка времени выполнения |Ошибка во время выполнения или ошибка времени выполнения ]]
>        - [[CppAbstract#Логические ошибки|Логические ошибки]]
>    - [[CppAbstract#Множественное наследование, одинаковые методы|Множественное наследование, одинаковые методы]]
>    - [[CppAbstract#Что такое интерфейс в ООП |Что такое интерфейс в ООП ]]
>    - [[CppAbstract#Виртуальное наследование. Ромбовидное наследование|Виртуальное наследование. Ромбовидное наследование]]
>    - [[CppAbstract#Работа с файлами. Запись в файл. C++ ofstream|Работа с файлами. Запись в файл. C++ ofstream]]
>    - [[CppAbstract#Чтение из файла. Ifstream |Чтение из файла. Ifstream ]]
>    - [[CppAbstract#Запись объекта класса в файл. Чтение объектов из файла|Запись объекта класса в файл. Чтение объектов из файла]]
>    - [[CppAbstract#Чтение и запись в файл. Fstream C++|Чтение и запись в файл. Fstream C++]]
>    - [[CppAbstract#Потоковый ввод вывод в файл. Перегрузка операторов << >>|Потоковый ввод вывод в файл. Перегрузка операторов << >>]]
>    - [[CppAbstract#Порядок записи и составления .h и .cpp файлов и их подключение |Порядок записи и составления .h и .cpp файлов и их подключение ]]
>    - [[CppAbstract#Правила написания переменных |Правила написания переменных ]]
>    - [[CppAbstract#Try catch. Обработка исключений в C++ |Try catch. Обработка исключений в C++ ]]



## Полезные ссылки

Справочник по терминам
https://www.w3schools.com/cpp/default.asp

Первые шаги: C++
Чтобы изучать Unreal Engine сначала нужно изучить С++ и понимать, как он устроен.
Я изучал С++ по этим видеоурокам: https://www.youtube.com/playlist?list=PLQOaTSbfxUtCrKs0nicOg2npJQYSPGO9r
После изучение синтексиса кода нужно изучать архитектуру. Для этого читаем про принципы SOLID и изучаем паттерны проектирования сразу под игры: https://gameprogrammingpatterns.com/contents.html

Знакомимся с Unreal Engine
Для знакомства с Unreal Engine я советую эти два курса:
Unreal Engine — полное руководство по разработке на С++ — https://www.udemy.com/course/unrealengine/?referralCode=1DEBE7F013238C387B46&couponCode=ST22MT240325G2

Professional Game Development in C++ and Unreal Engine — https://courses.tomlooman.com/p/unrealengine-cpp

Первый на русском, второй на английском.

Параллельно: математика
Параллельно можно изучать математику. Есть бесплатный плейлист на YouTube как раз для игровых разработчиков: https://www.youtube.com/playlist?list=PLW3Zl3wyJwWOpdhYedlD-yCB7WQoHf-My

## Вступление 

```cpp
#include <iostream>
using namespace std;

void main()
{
	setlocale(LC_ALL, "Rus");
	cout << "Привет" << endl;
}
```

Работа программы всегда ведется в графе функции 

```cpp
void main () //название функции, тела
{
//code
}
```

cout - читается как "c out" с аут 
endl - эндл, переноси на новую строку "end line" - > "endl"
## using namespace std 

**Namespace std** в C++ — это **пространство имён стандартной библиотеки C++ (iostream), которое содержит множество полезных функций и классов**. Таких как std, setlocale

Пространство имён позволяет группировать идентификаторы (например, переменные, функции, классы) в отдельные области, что помогает избежать конфликтов имён и упрощает организацию кода.

Чтобы использовать эти функции и классы в своём коде, необходимо указывать префикс std:: перед каждым идентификатором. Например, чтобы вывести на экран сообщение, можно использовать код: 

std::cout << "Hello, world!" << std::endl;

Также можно использовать директиву «using namespace std;», которая позволяет использовать все идентификаторы из пространства имён std без указания префикса std::. Однако необходимо быть осторожным при её использовании, так как это может привести к конфликтам имён и ошибкам компиляции. [1](https://pikabu.ru/story/using_namespace_std_10052704)

```cpp
//using namespace std;

void main()
{
	std::cout << "Привет" << std::endl;
}
```

## Comment 

```
//hello 

/*Hello*/
```

## Библиотеки 

```cpp
#include <iostream> //вывод в консоль
#include <math.h> //функции математики 
```

## Escape последовательности 

```cpp
/*

\b Удаление последнего выведенного символа 
\n Перейти на начало новой строки
\t Перейти к следующей позиции табуляции 

///////////////////////////////////////////

\\ Вывести обратную черту \
\" Вывести двойную кавычку "
\' Вывести одинарную кавычку '

*/
```

## Типы данных 

![[Pasted image 20241224045814.png]]

## Переменные 

```cpp
//тип_данных имя_переменной;

	int a = 5;
	
	a = 5;

	int Age, a, b;

	int Age = 10, a = 1, b = 2;

	double c = 1.5151;

	char a = 'f';

	bool a = true;

//вывод

	cout << a << endl;

	cout << Age << " " << a << " " << b << endl;
```

## Константы 

Константы объявляются большими буквами, принятая система разработки для облегчения последующего чтения 

```cpp
	const int COUNT_DAYS_IN_WEEK = 7;
	const char NEW_LINE = '\n';
	const char TAB = '\t';

	cout << COUNT_DAYS_IN_WEEK << "\n";
	cout << COUNT_DAYS_IN_WEEK << NEW_LINE;
	cout << COUNT_DAYS_IN_WEEK << NEW_LINE <<TAB << TAB;
```

В NEW_LINE будут храниться перенос в новую строку 
В TAB будет храниться табуляция, которая никогда не изменяется 

## Ввод данных 

`cin`  принадлежит пространству имен std и относится к библиотеке iostream 

Читается как "c in"  "c ин"

```cpp
	int Var, Var2;

	cout << "Введите число: ";
	cin >> Var;

	cout << "Введите число: ";
	cin >> Var2;

	cout << "Введите 2 числа: ";
	cin >> Var >> Var2;

	cout << "Вы ввели число: " << Var << endl;
	cout << "Число 1 = " << Var << endl << "Число 2 = " << Var2 << endl;
```

Введите число: 5
Введите число: 3
Число 1 = 5
Число 2 = 3

## Операторы. Арифметические действия с числами 

```cpp
//ОПЕРАТОРЫ 

// УНАРНЫЕ 
// БИНАРНЫЕ
// ТЕРНАРНЫЕ 

```

```Cpp
	// УНАРНЫЕ 
	int a = 5;
	cout << a << endl;
	a = -a;
	cout << a << endl;

```

Бинарные

![[Pasted image 20241224055715.png]]

% - остаток от деления 

![[Pasted image 20241224055911.png]]

![[Pasted image 20241224055902.png]]

```cpp
	int a = 5, b = 2, c;

	c = a + b;

	c = (2 + 2) * 2;
	
	cout << c << endl;
	cout << a + b << endl;
	cout << a * b << endl;
```

Операции умножения имеют приоритет над сложением и делением

```cpp
average = (double)(a + b + c) / 3; //операция приведения типов 
```

```cpp
#include <iostream>
using namespace std;

void main()
{
	setlocale(LC_ALL, "Rus");
	int a, b, c; 
	double average;
	cin >> a >> b >> c;
	cout << a + b + c << endl << a * b * c << endl;

	average = (double)(a + b + c) / 3; //операция приведения типов 
	cout << "Среднее арифметическиое: " << average << endl;
	cout << "Среднее арифметическиое: " << (double)(a + b + c) / 3 << endl;
}
```

5
3
5
13
75
Среднее арифметическиое: 4.33333

## Инкремент и декремент. Постфиксный и префиксный 

Добавляет или отнимает единицу. 

```
	int a = 1;
	cout << a << endl;

	a = a + 1;
	cout << a << endl;
	
	//постфиксный
	a++; //инкремент
	a--; //декремент 

	//префиксный 
	++a;
	--a;
```

```
	cout << a++ <<endl; 
	cout << ++a <<endl; 
```

Различия в постфиксном и префиксном. Что при выводе инкремент и декремент имеет меньший приоритет при выводе. 

при cout << a++ <<endl; 

Постфикс а++
а = 1, затем вывод а, прибавляет 1. 

Префикс. ++а
а = 1, затем прибавление 1, вывод а

```
	int a = 1, b;
	
	b = ++a * a++; //	b = ++a * a затем а + 1
	cout << b << endl;
```

Вывод 
b = 4
a = 3

```
	int a = 1, b;

	b = ++a * a;
	cout << b << endl;
	cout << a << endl;
```


Вывод 
b = 4
a = 2

## Сокращенные арифметические формы +=, -= и тд 

```
	int a = a + 1;
	a++;

	a = a + 20;
	a += 20;

	a = a - 10;
	a -= 10; 

	a = a * 2;
	a *= 2;

	a = a / 2;
	a /= 2;
}
```

## Операторы сранвения, равенства, логические 

```
	Операторы сравнения

<	- меньше
>	- больше  
<=	- меньше/равно
>=	- больше/равно

	Операторы равенства 

==	- равно
!=	- не равно

	Логические операторы объединения и отрицательная инверсия

&&	- и
||	- или
!=	- не
```

```cpp
	cout << (4 < 5) << endl; //true
	cout << (5 <= 5) << endl; //true
	cout << (5 > 5) << endl; //false
	
	cout << (4 == 5) << endl; //false
	cout << (5 == 5) << endl; //true
	cout << (5 != 5) << endl; //false
```

```cpp
	int a = 3;
	int b = 3;

	cout << !(a == b) << endl; //false
	cout << !(a != b) << endl; //true
```

```cpp
	cout << ((3 == 3) && (5 > 4)) << endl; //true
	cout << ((3 == 3) && (5 < 4)) << endl; //false

	cout << ((3 == 3) || (5 < 4)) << endl; //true
```

## if / else 

```cpp
	int a;

	if (a > 5)
	{
		cout << "var1" << endl;
	}
	else if (a == 5)
	{
		cout << "var2" << endl;
	}
	else
	{
		cout << "var3" << endl;
	}
```

```cpp
	int a;
	cin >> a;

	//проверка остатка от деления
	//if ((a %= 2) <= 0) 
	
	if (a % 2 <= 0)
	{
		cout << "Число четное " << a << endl;
	}
	else
	{
		cout << "Число не четное " << a << endl;
	}
```

## Switch 

Если много условий 

```cpp
	switch (выражение)
	{
	case значение1;
		действие1;
		break;
	case значение1;
		действие1;
		break;
	case значение1;
		действие1;
		break;
	default:
		действие по умолчанию;
		break;
	}
```

блок default будет выполняться для тех выражений кто не подходит под заданное выражение проверки
не является обязательным 

```cpp
	int a;
	cin >> a;

	switch (a)
	{
	case 1:
		cout << "Вы ввели 1" << endl;
		break;
	case 2:
		cout << "Вы ввели 2" << endl;
		break;
	default:
		cout << "Я не знаю этого числа" << endl;
		break;
	}
```

Можно использовать скобки

```cpp
	switch (a)
	{
	case 1:
	{
		cout << "Вы ввели 1" << endl;
		cout << "Вы ввели 1" << endl;
		cout << "Вы ввели 1" << endl;
		cout << "Вы ввели 1" << endl;
		cout << "Вы ввели 1" << endl;
		cout << "Вы ввели 1" << endl;
		cout << "Вы ввели 1" << endl;
		break;
	}

	case 2:
		cout << "Вы ввели 2" << endl;
		break;
	default:
		cout << "Я не знаю этого числа" << endl;
		break;
	}
```

калькулятор

```cpp
	int a, b, c;
	cin >> a >> b;

	cout << "Выберите математическую операцию" << endl <<
		"1. Сложение" << endl <<
		"2. Вычитание" << endl <<
		"3. Умножение" << endl <<
		"4. Деление" << endl;

	cin >> c;

	switch (c)
	{
	case 1:
		cout << "Сложение" << endl << a + b << endl;
		break;
	case 2:
		cout << "Вычитание" << endl << a - b << endl;
		break;
	case 3:
		cout << "Умножение" << endl << a * b << endl;
		break;
	case 4:
		cout << "Деление" << endl << (float)a / b << endl;
		break;

	default:
		cout << "Неправильно введены числа" << endl;
		break;
	}
```

## While 

```cpp
	while (утверждение)
	{
		действие для повторения
	}
```

```cpp
	int a = 0;

	while (a < 10)
	{
		cout << "Переменная a = " << a << endl;
		a++;
	}
```

Переменная a = 0
Переменная a = 1
Переменная a = 2
Переменная a = 3
Переменная a = 4
Переменная a = 5
Переменная a = 6
Переменная a = 7
Переменная a = 8
Переменная a = 9

## Do While 

Сначала вырежение выполнится в графе do и если значение выполнела true 

Цикл всегда хоть один раз но выполнится 

```cpp
	int a = 10;

	do
	{
		cout << "Переменная a = " << a << endl;
		a++;

	} while (a < 10);
```

Переменная a = 10

Разработать программу, которая выводит на экран линию из символов. Число символов, какой использовать символ, и какая будет линия - вертикальная, или горизонтальная - указывает пользователь.

```cpp
	int a = 0, quatity, SelectLine;
	char symbol;
	cin >> symbol >> quatity >> SelectLine;

	switch (SelectLine)
	{
	case 0:
	{
		while (a <= quatity)
		{
			cout << symbol;
			a++;
		}
	}
		break;
	case 1:
	{
		while (a <= quatity)
		{
			cout << symbol << "\n";
			a++;
		}
	}
	break;
	default:
		break;
	}
```

Написать программу, которая находит сумму всех целых нечетных чисел в диапазоне, указанном пользователе.

```cpp
	int ValueA, ValueB, sum = 0; 
	cin >> ValueA >> ValueB;

	while (ValueA <= ValueB)
	{
		if (ValueA % 2 != 0)
		{
			sum += ValueA;
			ValueA++;
			cout << ValueA;
		}
		else
		{
			ValueA++;
			cout << ValueA;
		}
	}
	cout << "\n" << sum;
```

## For 

```cpp
	for (int i = 0; i < 10; i++)
	{
		cout << "Переменная i = " << i << endl;
	}
```

i можно вынести, но ; в условие должно стоять

```cpp
	int i = 0;

	for (; i < 10; )
	{
		cout << "Переменная i = " << i << endl;
		i++;
	}
```

так тоже будет работать бесконечно 

```cpp
	for (; ;)
	{
		cout << "Переменная i = " << i << endl;
	}
```

Можно поставить два условия 

```cpp
	for (int i = 0, j = 10; i < 10 && j != 5; i++, j--)
	{
		cout << "Переменная i = " << i << endl;
		cout << "Переменная j = " << i << endl;
	}
```

## Break, ключевое слово 

Нужно что бы прервать и выйти из цикла 

```cpp
	for (int i = 0; ; i++)
	{
		cout << "Переменная i = " << i << endl;
		if (i == 5)
		{
			break;
		}
	}
```

```cpp
	int i = 0;

	while (true)
	{
		cout << "Переменная i = " << i << endl;
		i++;
		if ( i == 6)
		{
			break;
		}
	}
```

## Continue 

```cpp
	for (int i = 0; i < 5; i++)
	{
		if (i == 2)
		{
			continue;
		}
		//пропускает весь код ниже 
		cout << "Переменная i = " << i << endl;
	}
```

Переменная i = 0
Переменная i = 1
Переменная i = 3
Переменная i = 4

Когда в цикле сработала проверка, выполнилось ключевое слово continue

Continue пропускает ход и переходит к циклу в начало 

## Где лежит .exe 

\YOURproject\Debug

![[Pasted image 20241225031733.png]]

![[Pasted image 20241225033042.png]]

Добавить в конце, что бы не закрывалось

```
	system("pause");
```

либо можно сделать ввод данных и программа будет ждать когда вы введете и до тех пор не закроется 

```
	int a;
	cin >> a;
```

## GOTO 

Можно пропустить часть кода 

```cpp
	cout << "Один" << endl;

	goto link;

	cout << "Два" << endl;

	cout << "Три" << endl;

	link:

	cout << "Четыре" << endl;

	cout << "Пять" << endl;
```

Один
Четыре
Пять

## Отладчик 

F10  идет по каждой строке 

![[Pasted image 20241225074430.png]]

F9 точка остановки 

![[Pasted image 20241225074610.png]]

что бы перейти дальше надо нажать так же F10

![[Pasted image 20241225075133.png]]

Можно закрепить переменную и смотреть за ее изменением 

![[Pasted image 20241225075149.png]]

Shift + F5 - остановить 

F5 перейти от одной точки остановки к другой 

F11 - шаг с заходом что бы зайти в функции в коде 

## Вложенный цикл 

```cpp
	for (int i = 1; i < 5; i++)
	{
		cout << "Сработал 1й цикл for итарация = " << i << endl;

		for (int j = 1;  j < 5;  j++)
		{
			cout << "\t Сработал 2й цикл for итерация = " << j << endl;
		}
	}
```

Сработал 1й цикл for итерация = 1
         Сработал 2й цикл for итерация = 1
         Сработал 2й цикл for итерация = 2
         Сработал 2й цикл for итерация = 3
         Сработал 2й цикл for итерация = 4
Сработал 1й цикл for итерация = 2
         Сработал 2й цикл for итерация = 1
         Сработал 2й цикл for итерация = 2
         Сработал 2й цикл for итерация = 3
         Сработал 2й цикл for итерация = 4
Сработал 1й цикл for итерация = 3
         Сработал 2й цикл for итерация = 1
         Сработал 2й цикл for итерация = 2
         Сработал 2й цикл for итерация = 3
         Сработал 2й цикл for итерация = 4
Сработал 1й цикл for итерация = 4
         Сработал 2й цикл for итерация = 1
         Сработал 2й цикл for итерация = 2
         Сработал 2й цикл for итерация = 3
         Сработал 2й цикл for итерация = 4

Написать программу, которая выводит на экран прямоугольник символом *. Высота и ширина задаётся пользователем

```cpp
	int a, b;
	cin >> a >> b;

	for (int i = 0; i < a; i++)
	{
		if (b > 0)
		{
			for (int j = 0; j < b; j++)
			{
				cout << "*";
			}
		}
		cout << endl;
	}
```

```
5
5
*****
*****
*****
*****
*****
```

## Массив 

Совокупность переменных, которая позволяет хранить несколько однотипных значений. Каждая является самостоятельной единицей 

```cpp
	//тип_данных имя [колличество элементов];

	int arr[4];

	arr[0] = 5;
	arr[1] = 7;
	arr[2] = 10;
	arr[3] = 3333;

	cout << arr[0] << endl;
```

Индекс начинается с 0. 
Заполнять массив можно по любому из индексов 

Если мы обратимся с не существующему индексу, например arr [10]
это выведет либо случайное число, либо ошибку 

## Инициализация массива 

```cpp
	int arr[] = {1, 66, 12, 2};
	
	int arr[]{1, 66, 12, 2 };
	
	int arr[1000]{1, 66, 12, 2 }; //остальные индексы забиваются нулями
	
	int arr[4]{}; //забьется нулями 
```

## Вывод массива. Заполнение 

```cpp
	int arr[SIZE]{ 55, 512, 2, 123 , 95 };
```

```cpp
	const int SIZE = 5;

	int arr[SIZE];

	for (int i = 0; i < SIZE; i++)
	{
		arr[i] = i;
	}


	for (int i = 0; i < SIZE; i++)
	{
		cout << arr[i] << endl;
	}
```

0
1
2
3
4

## sizeof 

Возвращает объем памяти выделеную на переменную 

Возвращает длину в байтах, либо типы данных, либо переменных которые мы используем вместе с ключевым словом 

```cpp
	int a;

	cout << sizeof(int) << endl;
	cout << sizeof(double) << endl;
	cout << sizeof(a) << endl;
```

4
8
4

Можно узнать сколько символов в массиве. Деление. Узнав размер байтов самого массива 

```cpp
	int arr[]{23, 33, 545, 111, 353};
	
	int a = sizeof(arr);
	int b = sizeof(int);

	cout << sizeof(arr)/sizeof(int) << endl;

	cout << endl;

	for (int i = 0; i < sizeof(arr) / sizeof(int); i++)
	{
		cout << arr[i] << endl;
	}
```

Какой бы мы тип массива, такая запись всегда будет работать корректно. Берется размер всего массива и размер первого его элемента. Они все будут принадлежать одному типу всегда 

```cpp
	int arr[]{23, 33, 545, 111, 353};

	for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		cout << arr[i] << endl;
	}
```

## rand. srand. rand задать диапазон. srand time null. Генератор случайных чисел. randomize 

Генератор случайных чисел будет работать используя время. Которое считается в секундах с начала 1970. 

```cpp
#include <iostream>
#include <ctime>

using namespace std;

void main()
{
	setlocale(LC_ALL, "ru");

	srand(time(NULL));
	//будет считать новое число. Будет считать время от 1970г в секундах. Так каждое число всегда будет разное 

	int a = rand() % 10; //генератор случайных чисел от 0 до 10
	int a = rand() % 10 + 5; //генератор случайных чисел от 5 до 15

	cout << a << endl;

}
```

```cpp
#include <iostream>
#include <ctime>

using namespace std;

void main()
{
	setlocale(LC_ALL, "ru");

	srand(time(NULL)); //можно закоменитировать что бы массив заполнялся всегда одинаковыми числами 

	int const SIZE = 10;

	int arr[SIZE];

	for (int i = 0; i < SIZE; i++)
	{
		arr[i] = rand() % 100; //от 0 до 100
	}

	for (int i= 0; i < SIZE; i++)
	{
		cout << arr[i] << endl;
	}
}
```

```cpp
#include <iostream>
#include <ctime>
using namespace std;

//Заполнить массив из 10 элементов. От 0 до 20. В массиве не должно быть одинаковых значений 
//нужно сделать проверку со всеми прошлыми значениями массива 
//найти самое маленькое число и вывести его на экран 


void main()
{
	setlocale(LC_ALL, "ru");

	srand(time(NULL));

	const int SIZE = 10;
	int arr[SIZE];
	int min;
	bool AlreadyThere;

	for (int i = 0; i < SIZE; )
	{
		AlreadyThere = false;
		int NewRandomValue = rand() % 20;
		for (int j = 0; j < i; j++)
		{
			//проверка если ли такой же элемент
			if (arr[j] == NewRandomValue)
			{
				AlreadyThere = true;
				break;
			}
		}

		//проверка переходить ли к след элементу
		if (!AlreadyThere)  //не 
		{
			//проверка первый ли элемент массива 
			//проверка является ли этот элемент мин
			if (i == 0)
			{
				min = NewRandomValue;
			}
			else if (NewRandomValue < min)
			{
				min = NewRandomValue;
			}
			arr[i] = NewRandomValue;
			i++;
		}
	}

	//вывод
	for (int i = 0; i < SIZE; i++)
	{
		cout << arr[i] << endl;
	}

	cout << "\n" << min << endl;
}
```

## Двумерный массив 

![[Pasted image 20241226045426.png]]

По такой то строке и по такой то колонке 

```
a[row][col]
  |
row - вертикальная  
col - горизонтальная  ---

```

![[Pasted image 20241226045708.png]]

## Трехмерный массив 

![[Pasted image 20241226050000.png]]

## Двумерный массив. Инициализация. Индексы 

![[Pasted image 20241226063800.png]]

Сначала идет вертикальная потом горизонтальная 

```cpp
	//обычно устанавливают константы для строк и колонок 

	const int ROW = 3;
	const int COL = 4;

	int arr[ROW][COL];
	int arr[ROW][COL]{}; //инициализация нулями 
	
	cout << arr[1][1] << endl;

	arr[2][0] = 1111111;

	arr[1][1] = 55;
```

```cpp
	int arr[ROW][COL]
	{
		{2, 5, 6, 2},
		{15, 153, 53, 3},
		{15, 41, 1, 3}
	};
```

Колонки всегда нужно иницилизировать. их количество. Так же можно писать в строчку. 

```cpp
	int arr[][COL]
	{
		{2, 5, 6, 2},
		{15, 153, 53, 3},
		{15, 41, 1, 3},
		{15, 41, 1, 3},
		{15, 41, 1, 3}
	};
```

## Двумерные массив. Вывод. Заполнение 

```cpp
	const int ROWS = 5;
	const int COLS = 8;

	int arr[ROWS][COLS];

	for (int i = 0; i < ROWS; i++)
	{
		for (int j = 0; j < COLS; j++)
		{
			arr[i][j] = rand() % 10; //не больше 10
		}
	}

	for (int i = 0; i < ROWS; i++)
	{
		for (int j = 0; j < COLS; j++)
		{
			cout << arr[i][j] << "\t";
		}
		cout << endl;
	}
```

1       7       4       0       9       4       8       8
2       4       5       5       1       7       1       1
5       2       7       6       1       4       2       3
2       2       1       6       8       5       7       6
1       8       9       2       7       9       5       4

## Функции.  Синтаксис. Объявление, реализация функции. Параметры, аргументы. 

```
	тип_возвращаемого_значения имя_функции(параметры)
	{
		блок_повторяющегося_кода(тело);
	}
```

Если функция ничего не возвращает. Обозначается void.

```
void foo()
{
	cout << "Я функция, меня вызвали!" << endl;
}
```

Можно записать и так. Компилятор сам позаботиться о return 

```
void foo()
{
	cout << "Я функция, меня вызвали!" << endl;

	return;
}
```

```
return - вернуть результат работы
```

Объявление функции должно быть до ее вызова. 

```cpp
//инициализация функции
void foo()
{
	cout << "Я функция, меня вызвали!" << endl;
}

void main()
{
	setlocale(LC_ALL, "ru");

	foo(); //вызов функции
}
```

 Функция может быть различных типов int, double, char, bool. Для них всех должен быть return

```cpp
int Sum(int a, int b)
{
	int result;

	result = a + b;

	return result;
}

// лучше записывать так 
int Sum(int a, int b)
{
	return a + b;
}

void main()
{
	setlocale(LC_ALL, "ru");

	int c;
	int q = 11;
	int w = 12;

	c = Sum(2, 5);
	c = Sum(q, w);

	cout << c << endl;
	cout << Sum(q, w) << endl;
}
```

Подсказывает какие параметры подставить

![[Pasted image 20241226080337.png]]

Еще возможная запись с типов double

```cpp
double Sum(double a, double b, double c)
{
	return a + b + c;
}
```

## Передача параметров в функцию по значению. Параметры функции. Передача аргументов.

Передача параметров по значению. В функции Foo(int a) а будет передаваться по значению 

Будет вывод 1. Так как а является разными переменными в функциях

```cpp
void Foo(int a)
{
	a++;
}

void main()
{
	setlocale(LC_ALL, "ru");

	int a = 1;

	Foo(a);

	cout << a << endl;
}
```

Правильное решение 

```cpp
int Foo(int a)
{
	return ++a;
}

void main()
{
	setlocale(LC_ALL, "ru");

	int value = 1;

	value = Foo(value);

	cout << value << endl;
}
```

## Передать в функцию массив

Массив не передается по значению. Передаем не сам массив, а я ярлык на массив. Ссылку на него. 

Все изменения, которые происходят с массивом в функции, передадутся основному массиву, в отличие от функции. Потому что массив передается не по значению, а по ссылке. Передается не сами значения массива, а ярлыки. Ссылки на него. 

Всегда должны передавать размер массива в функцию

```
	int a sizeof(arr);
```

Sizeof работать не будет. Так как передается ссылка, которая меньше основного массива в байтах 

```cpp
void FillArray(int arr[], const int SIZE)
{

}

void main()
{
	setlocale(LC_ALL, "ru");

	const int SIZE = 10;
	int arr[SIZE];



}
```

```cpp
//Функция заполняет массив 
void FillArray(int arr[], const int SIZE)
{
	for (int i = 0; i < SIZE; i++)
	{
		arr[i] = rand() % 10;
	}
}

//Функция выводит массив 
void PrintArray(int arr[], const int SIZE)
{
	for (int i = 0; i < SIZE; i++)
	{
		cout << arr[i] << endl;
	}
}

void main()
{
	setlocale(LC_ALL, "ru");

	const int SIZE = 10;
	int massive[SIZE];

	FillArray(massive, SIZE);
	PrintArray(massive, SIZE);
}
```

Номер массива одинаковый 0х0099f9d0 

![[Pasted image 20241227012901.png]]

Для двумерного массив нужно будет передавать вместо size - cols, rows

## Прототипы функции 

```cpp
//прототипы функции. Объявляют где то вверху. функцию foo. 
//Что бы функции можно было вызвать в любом месте 

void foo();
void foo1();
void foo2();


void foo()
{
	cout << "Я функция, меня вызвали!" << endl;
	foo1();
}


void main()
{
	setlocale(LC_ALL, "ru");

	foo();
	foo2();
}

void foo1()
{
}

void foo2()
{
}
```

```cpp
//при работе с параметрами в прототип нужно передавать параметры

//прототип 
void foo(int a, int b);

void foo(int a, int b)
{
	cout << "Я функция, меня вызвали!" << endl;
}


void main()
{
	setlocale(LC_ALL, "ru");
	foo(5, 6);
}
```

## Область видимости. 

Фигурные скобки {} создают блок, переменные созданные там не видны за его приделами. Они являются областью видимостью 

```cpp
//{} - область видимости функции main

void main()
{

}
```

```cpp
void main()
{
	setlocale(LC_ALL, "ru");

	//переменная a будет видна только в фигурные скобках if 
	if (true)
	{
		int a;

		a = 0;
	}
}
```

Что бы использовать переменную в двух областях, нужно инициализировать ее за приделами вложенной области. 

```cpp
void main()
{
	setlocale(LC_ALL, "ru");

	//инициализация переменной за приделами вложенной области 
	int a;

	if (true)
	{
		a = 0;
	}

	a = 0;
}
```

```cpp
void main()
{
	setlocale(LC_ALL, "ru");

	//пример с циклом for 
	for (int i = 0; i < 10; i++)
	{
		i = 10;
	}

	//i - не определен. ошибка 
	i = 5;
}
```

```cpp
//искусственное ограничение 

void main()
{
	{
		int a;
		a = 0;
	}

	a = 55; 
}
```

## Глобальные и локальные переменные. 

```cpp
//глобальная переменная. К ней можем обратиться где угодно 
//создавать много глобальных переменных - дурной тон 

int a;

void foo()
{	
	//локальная переменная 
	int z;
}

void main()
{
	a = 55; 
}
```

Различия глобальной переменной и локальной. Что при пустом инициализировании переменной. Локальная переменная инициализируется мусором. Для глобальной переменной по умолчанию значение 0. 

![[Pasted image 20241227024823.png]]

![[Pasted image 20241227024838.png]]

Действия над глобальной переменной в функциях будут влиять на нее.

```cpp
int a;

void foo()
{	
	a++; 
}

void main()
{
	foo();
	a++;

	cout << a << endl;
}
```

Вывод: 2

 Дополнение: для локальных функция необходимо переприсваивать значение полученного результат функции к переменной 

```cpp
	value = Foo(value);
```

```cpp
int a;

//Если у функции и глобальной переменной будут одинаковые значения. То функция возьмет локальную свою переменную и будет работать с ней
void foo(int a)
{	
	a++;
}

void main()
{
	foo(2);
	a++;

	//Вывод 1. Так как функция работала со своей локальной переменной 
	cout << a << endl;
}
```

## Аргументы или параметры по умолчанию 

Задают определенную поведение функции. до тех пор пока не сказать делать что то другое 

```cpp
//Параметр по умолчанию int a = 5, double b = 0.5

void foo(int a = 5, double b = 0.5)
{
	for (int i = 0; i < a; i++)
	{
		cout << "#" << endl;
	}
}

void main()
{
	//параметр по умолчанию 5 заменится на 3, второй параметр double останется по умолчанию
	foo(3);
	
	//замена всех параметров 
	foo(5, 0.3);

	//параметры по умолчанию 
	foo();
}
```

![[Pasted image 20241227030146.png]]

Параметры без умолчанию всегда должны идти в начале. 

```cpp
void foo(int q, int a = 5, double b = 0.5)
```

## Inline. Ключевое слово. Встраиваемая функция

Нужно для оптимизации и быстродействия кода. 

Позволяет функции быть встроенной в код на этапе компиляции. 

Когда компиляция код доходит до функции. Она выходит из основного блока код и идет в функцию. Затем выполняет расчеты и возвращается в основной блок кода. inline позволяет не выходить из основного блока кода, а сделать расчеты сразу 

![[Pasted image 20241227092557.png]]

inline может не всегда работать и зачастую в компиляторах уже существуют подобные вещи. Если же в коде много ветвлений if else, inline может вообще не сработать. 

не будет работать если будут циклы или рекурсия. 

Сама программа будет весить чуть больше, но не сильно

```cpp
inline int Sum(int a, int b)
{
	return a + b;
}

void main()
{

}
```

## Перегрузка функции. Как ее вызвать

Можно написать несколько функций с одинаковым названием. Но с различным действием. Внутри могут различаться реализацией.  Может так же работать с различными типами. 

```cpp
int Sum(int a, int b)
{
	a++;
	return a + b;
}

double Sum(double a, double b)
{
	return a + b;
}

void main()
{
	Sum()
}
```

![[Pasted image 20241227084647.png]]
+1 overload 

У нее больше 1 реализации.  Говорит о том что можно использовать две разные реализации. 

![[Pasted image 20241227084730.png]]

![[Pasted image 20241227084853.png]]

Можно так же добавлять больше параметров

```cpp
int Sum(int a, int b, int c)
{
	return a + b + c;
}

int Sum(int a, int b)
{
	return a + b;
}

double Sum(double a, double b)
{
	return a + b;
}

void main()
{
	cout << Sum(5, 6) << endl;
	cout << Sum(5.1, 3.3) << endl;
}
```

![[Pasted image 20241227085123.png]]

## Шаблонные функции 

создавая темплейт, перегружая функцию можно использовать любой тип параметров

```cpp
//T - условное того типа, которое будем принимать 
//Можно написать что угодно, но принято что типы используешиеся в шаблонах именуют T от type

template <typename T>
T Sum(T a, T b)
{
	return a + b;
}
```

Компилятор подсказывает что функция шаблонная 

![[Pasted image 20241227091051.png]]

T - не может быть разными типами 

![[Pasted image 20241227091338.png]]

Можно сделать что бы функция принимала разные типы. Будет возвращать T1. как написано в typename 

```cpp
template <typename T1, typename T2>
T1 Sum(T1 a, T2 b)
{
	return a + b;
}

void main()
{
	setlocale(LC_ALL, "ru");

	cout << Sum(5, 10.4) << endl;
}
```

```cpp
template <typename T1, typename T2>
void Sum(T1 a, T2 b)
{
	cout << a << endl;
	cout << b << endl;
}

void main()
{
	setlocale(LC_ALL, "ru");

	Sum(2.5, "параметр");
}

```

2.5
параметр

typename и class одно и тоже. Можно использовать так и так. Typename использовалось в C. Class пришло уже в C++. 
Смешивать не надо 

```cpp
template <class T>
void Sum(T a)
{
	cout << a << endl;
}

void main()
{
	setlocale(LC_ALL, "ru");

	Sum(2);
}
```

## Функции и стек. Стек алгоритмов. Стек рекурсии. 

Стек - область памяти, где выполняется программа. Выполняется по типу последний зашел - первый вышел. Задача которая помещена последний, выполняется самой первой. 

![[Pasted image 20241227092943.png]]

Если вы попытаетесь положить в стек, который заполнен. Программа упадет и выйдет ошибка Stack Overflow. 

Стек можно представить в виде сосуда с заполненными тарелками. Если нужно достать первую тарелку. То сначала нужно вытащить все тарелки сверху. 

![[Pasted image 20241227093203.png]]

## Рекурсия. Рекурсия программирования. Рекурсия и цикл. 

Рекурсия - вызов программы самой себя непосредственно или косвенно
В нашем случае это вызов функции самой себя. 

Заходя в функцию. Функция вызывает сама себя. Когда в нее снова заходит снова вызывает себя. Снова заходит, снова себя и тд.. В конце приводит к заполнению стека и крашу. 

```cpp
void Foo()
{
	Foo();
}

void main()
{
	setlocale(LC_ALL, "ru");

	Foo();
}
```

![[Pasted image 20241227093728.png]]

Похож на цикл while. 

```cpp
int Foo(int a)
{
	if (a < 1)
		return 0;

	a--;
	cout << a << endl;

	return Foo(a);
}

void main()
{
	setlocale(LC_ALL, "ru");

	Foo(5);
}```

Сначала функция заполняется, затем сверху подставляя значения она выводится. И каждая из задач очищается. В нашем случае в конце, функция с самом конце возвращается в main в foo() и передает ей значение из задачи выше. 

![[Pasted image 20241227095125.png]]

![[Pasted image 20241227095247.png]]

## Рекурсия. Факториал числа. Рекурсия факториала. 

Суть рекурсии. Что не нужно знать как именно и сколько итераций будет. Когда сработают два if и функция выведет значения. Затем начнет вычисления умножений между собой.

Каждый раз вызывая функцию, она ждем следующую, желая умножить результат ее работы на себя, пока значение не получится. Выход из рекурсия является только if. Когда функция становится равна какому то значению. 

```cpp
/*
	N! = N * (N-1)1

	! - вычислять факториал
	N - число


	3! = 3*(3-1)!
	2! = 2 * (2 - 1)!
	1! = 1
*/

int Fact(int N)
{
	if (N == 0)
		return 0;
	if (N == 1)
		return 1;

	return N * Fact(N - 1);
}

void main()
{
	setlocale(LC_ALL, "ru");

	cout << Fact(5) << endl;
}
```

![[Pasted image 20241228025807.png]]

![[Pasted image 20241228025926.png]]

5 * 24 = 120 

## Динамическая память. Утечка памяти. Стек и куча. Статическая память. 

![[Pasted image 20241230013307.png]]

Статическая память слева. Точка это ссылка на динамическую. 
Массив- это всегда статическая память. Мы указывает сколько элементов должно быть в массиве. 
ссылка может обращаться в области в динамической памяти и вызывать ее 
Утечка памяти это когда прошлые не используемые объемы памяти не удаляются. Память переполняется и ломается. 
Куча это все пространство где находится статическая и динамическая память. 

## Указатели. 

Указатели - переменная, которая содержит адрес другой переменной или объекта. 

![[Pasted image 20241230014319.png]]

```cpp
int a = 5;

int *px = &a;

"тип данных" "название указателя, начинается с p" = "ссылка на данные"

Переменная *px служит указателем на место где лежит переменная a. 

Место равно = 0х000CD*

Операция разименования, если мы хотим получить именно адрес в оперативной памяти, то нужно убрать * звездочку из названия переменной. Если мы хотим обращаться к адресу указателя. 

cout << *px << endl;

*px2 = 2;

теперь а будет равна 2
и px тоже будет равна 2

То есть любое изменение указателя влияет на ссылочный объект, которое отобразится на всех остальных указателях на этот объект

И если мы напрямую изменим значение ссылочной переменной 

а = 3;

то в области памяти все указатели на этот объект тоже изменяться 
```

```cpp

	int a = 5;

	int *px = &a;

	//int - тип переменой 
	//* - что это указатель
	//& - оператор взятие адреса 

	//берем адрес, переменной a и присваиваем его переменной px

	//p-pointer. Указатель. Принято что если есть какой то указатель. То в начале имени указывается p. Что это указатель. 

	double* px = &a; // a = int 

	//Если вы хотите создать указатель на данные с типом int. То нужно создать указатель с типом int
```

![[Pasted image 20241230014828.png]]

```cpp
	int a = 5;

	int *px = &a;

	cout << px << endl; //получим ссылку 

	cout << *px << endl; //получим реальной значение данных, разименовать 
```

0073FA54
5

Можно заменять значение переменной через указатель. Присваивая значения указателю. 

```cpp
	int a = 5;

	int *px = &a;

	int* px2 = &a;

	cout << "px \t" << px << endl;
	cout << "px2 \t" << px2 << endl;

	*px2 = 2;

	cout << "a \t" << a << endl;
	cout << "px \t" << *px << endl;
```

px      00B5FE1C
px2     00B5FE1C
a       2
px      2

## Арифметика указателей. Указатели и массивы. Массив это указатель. 

Если имя массива - указатель на его первый элемент. А мы присваиваем pArr ссылку на первый элемент нашего массива. А массив это непрерывный область памяти. То прибавив к памяти промежуток байт. То получим индекс этого массива 

```cpp
	const int SIZE = 5;
	int arr[SIZE]{ 4, 55, 51 ,3 ,3 };

	for (int i = 0; i < SIZE; i++)
	{
		cout << arr[i] << endl;
	}

	cout << "======================" << endl; 
	int* pArr = arr;

	cout << "arr \t" << arr << endl;
	cout << "pArr \t" << pArr << endl;

	cout << "======================" << endl;

	for (int i = 0; i < SIZE; i++)
	{
		//cout << pArr[i] << endl;
		cout << *(pArr+i) << endl;
	}
```

4
55
51
3
3

arr     0045F710
pArr    0045F710

4
55
51
3
3

```cpp
	const int SIZE = 5;
	int arr[SIZE]{ 4, 55, 51 ,3 ,3 };

	//Вывод одного и того же

	//прибавляю единицу к байтам. Мы сдвигаемся к след значению 
	//размер int равен 4 байта. Поэтому каждый шаг будет размеров в 4 байта 

	cout << *(arr+0) << endl;
	cout << *(arr+1) << endl;
	cout << *(arr+2) << endl;
	cout << endl;

	for (int i = 0; i < SIZE; i++)
	{
		cout << arr[i] << endl;
	}

	cout << endl;

	for (int i = 0; i < SIZE; i++)
	{
		cout << (arr+i) << endl; //получим список адресов памяти
	}

	cout << endl;

	for (int i = 0; i < SIZE; i++)
	{
		cout << *(arr+i) << endl; 
	}
```

4
55
51

4
55
51
3
3

00B6F7A0
00B6F7A4
00B6F7A8
00B6F7AC
00B6F7B0

4
55
51
3
3

Опасность. В том что при прибавлении к и переходу к другому значению. Мы можем попасть в другое значение. Взять не из нужного массива, а с большим шагом попасть во внутреннюю память и достать от туда значения. 

Лучшим будет если программа сама сломается, чем будут взяты значения и будут использоваться. Так как можно не понять, почему программа работает так. 

![[Pasted image 20241230022534.png]]

Арифметика указателей. Может добавить к индексу числа и перейти к другому числу.  Шаг в 4 байта. 

![[Pasted image 20241230084541.png]]

## Передача параметров в функцию по указателю 

```cpp
//Это переменная больше нигде не видна кроме этой функции. тк функция не возвращает значение 
//Пока функция не возвращает значение, переменная не меняется 

void Foo(int a)
{
	a++;
}
```

```cpp
//Если сделать вот так pa++ то мы просто сдвинем ячейку памяти 041155 и получим какое то значение 
//Что бы изменить само значение указателя, его нужно разименовать 

void Foo(int *pa)
{
	(*pa)++;

	//(*pa) = 555;
}

void main()
{
	setlocale(LC_ALL, "ru");

	int a = 0;

	cout << a << endl;

	Foo(&a); //нужно взять адрес нашей переменной a

	cout << a << endl;

}
```

0
1

Операция разименования - операция взятия значения. Мы получаем не копию, а данные. И мы можем изменить эти данные. 
Так как мы работали с данными 

![[Pasted image 20241230040534.png]]

Пример работы по значению. При работе со значением данные копируются в новый блок. И связи между ними нет. Одному блоку будет все равно что происходит со вторым. 
При работе с указателем же, данные из второго блока берутся из первого и изменяются на прямую. 

![[Pasted image 20241230040658.png]]

## Возврат нескольких значений функция через указатели. Функция возвращает несколько значений. 

Функция создается для отдельно какой то вещи 

```cpp
#include <iostream>
using namespace std;

void Foo(int *pa, int *pb, int *pc)
{
	(*pa) = 555;

	(*pb)++;

	(*pc) = -20;

}

void main()
{
	setlocale(LC_ALL, "ru");

	int a = 0, b = 0, c = 1;

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;
	
	cout << "Foo" << endl;
	Foo(&a, &b, &c);

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;
}
```

a = 0
b = 0
c = 1
Foo
a = 555
b = 1
c = -20

Напишите функцию, меняющую местами значения переменных с помощью указателей.

```cpp
#include <iostream>
using namespace std;

void Foo(int *pa, int *pb)
{
	int value = *pa;
	*pa = *pb;
	*pb = value;
}

void main()
{
	setlocale(LC_ALL, "ru");

	int a = 5, b = 6;

	Foo(&a, &b);

	cout << a << b << endl;
}
```

65

## Ссылки 

когда мы объявляем ссылку, мы должны сразу ее инициализировать 

```cpp
	int a = 5;

	int* pa = &a;

	//ссылка на а 
	int &aRef = a; 

	//хранят в себе ссылку на адрес памяти переменной а
	//У них нет оператора разименования, они сразу работают со значением на которую указывают 

	cout << "*pa \t" << pa << endl;
	cout << "&aRef \t" << aRef << endl;
```

Арифметика к ссылкам 

```cpp
	cout << "&aRef \t" << aRef << endl;

	aRef++;

	cout << "&aRef \t" << aRef << endl;
```

&aRef   5
&aRef   6

Если мы запишем в ссылку какие то значения для переменной, то к переменной тоже присвоится это значение 

```Cpp
	int a = 5;

	int* pa = &a;

	int &aRef = a;
	
	cout << "a \t" << a << endl;
	cout << "&aRef \t" << aRef << endl;

	aRef = 55;

	cout << "a \t" << a << endl;
```

a       5
&aRef   5
a       55

Указатель может хранить в себе 0. Ссылка нет. 

```cpp
	int *pp = NULL;
	int *pp = 0;
	int *pp = nullptr;
```

Взаимодействие ссылок и указателей 

```cpp
	int a = 5;

	int* pa = &a;

	int &aRef = a;

	int* ppa = &aRef;
```

Мы объявляем переменную. Ее адрес мы перемещаем в ссылку. Затем мы создаем указатель, и туда помещаем ссылку. В таком случае если мы сделаем изменения с указателем * paa все изменения перейдут переменной

![[Pasted image 20241230085842.png]]

```cpp
	int a = 5;

	int* pa = &a;

	int &aRef = a;

	int* ppa = &aRef;
	
	cout << "a \t" << a << endl;

	*ppa = 12;

	cout << "a \t" << a << endl;
```

a       5
a       12

Указали и ссылки нужны для экономии ресурсов компьютера. Когда будут большие объекты, то копировать их станет проблематично. А так можно указать на них маленькую ссылку в 4 байта. 

## Передача параметров в функцию по ссылке. Разница между ссылкой и указателем 

Для ссылок достаточно передать значение в переменную, что бы присвоить оригинальной переменной значение 

```cpp
//принимает ссылку на значение
void Foo(int a) 
{
    a = 1;
}

//принимает параметр по ссылке 
void Foo2(int &a) 
{
    a = 2;
}

//принимает параметр по указателю 
void Foo3(int *a) 
{
    *a = 3;
}

void main()
{
    int value = 5;
    cout << "value = " << value << endl << endl;

    cout << "Foo = " << endl;
    Foo(value);
    cout << "value = " << value << endl << endl;

    cout << "Foo2 = " << endl;
    Foo2(value);
    cout << "value = " << value << endl << endl;

    cout << "Foo3 = " << endl;
    Foo3(&value);
    cout << "value = " << value << endl << endl;
}
```

value = 5

Foo =
value = 5

Foo2 =
value = 2

Foo3 =
value = 3

Переменная в Foo. равна 5 потому что в функции создалась копия и затем функция уже начала работать со значением, которое никак не относится к value и функция не возвращает и не присваивает это значение назад. 

## Возврат нескольких значений функций через ссылки

```cpp
//принимает 3 ссылки
void Foo(int &a, int &b, int &c)
{
    a = 10;
    b *= 2;
    c -= 100;
}

void main()
{
    int a = 0, b = 4, c = 34;
    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
    cout << "c = " << c << endl;

    cout << "Foo" << endl;

    Foo(a, b, c);

    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
    cout << "c = " << c << endl;
}
```

ШАБЛОННУЮ функцию которая меняет местами значения 2-х переменных с помощью ССЫЛОК

```cpp
#include <iostream>
using namespace std;

template <class T> 
void Foo(T &a, T &b)
{
    T value = a;
    a = b;
    b = value;
}

void main()
{
    setlocale(LC_ALL, "ru");
    string a = "Привет!";
    string b = "Пока";
    cout << "a = " << a << endl;
    cout << "b = " << b << endl;

    cout << "Foo" << endl;

    Foo(a, b);

    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
}
```

## New C++. Что это пример. C++ new delete. 

![[Pasted image 20250102082343.png]]

Язык C++ не имеет автоматического сборщика мусора. Если мы создаем место в динамической памяти. То никто кроме нас не позаботится о очистке.

Обычно оператор new используется для массива. 

Использовать как привычку писать после оператора new. оператор delete для очистки памяти. Что бы не забыть и получить утечку памяти

Утечка памяти - перезаполнение памяти, приводящее к крашу программы 

```cpp
void main() 
{
    // оператор new выделяет дополнительную память для нужд программы 
    int *pa = new int;
    *pa = 10;
    cout << *pa << endl;
    
    //очищает оперативную память. указываем указатель 
    delete pa;
}
```

![[Pasted image 20250102083101.png]]

Данные удалены. Но все еще сохранен адрес памяти и мы все еще можем туда обращаться 

![[Pasted image 20250102083110.png]]

## Null pointer. nullptr. null

При удалении оператором delete мы удаляем очищаем значение, но остается адрес памяти. 

nullptr - null pointer - отдельный тип данных
null - 0

```Cpp
#include <iostream>
using namespace std;

void main() 
{
    // оператор new выделяет дополнительную память для нужд программы 
    int *pa = new int;
    *pa = 10;
    cout << *pa << endl;
    
    //очищает оперативную память. указываем указатель
    delete pa;

    //нулевой указатель, указывает на ноль 
    //говорит о том что бы компилятор забыл адрес 
    pa = 0;

    //макрос, компилятор заменяет все слова на 0 
    pa = NULL;

    //можем снова вызвать, если не будет 0, то будет ошибка 
    delete pa;
    cout << pa << endl;
}
```

```cpp
    // оператор new выделяет дополнительную память для нужд программы 
    int *pa = new int;
    *pa = 10;
    cout << *pa << endl;
    //очищает оперативную память. указываем указатель
    delete pa;

    //макрос, компилятор заменяет все слова на 0 
    pa = NULL;

    //можем снова вызвать, если не будет 0, то будет ошибка 
    delete pa;
    cout << pa << endl;
```

10
00000000

```cpp
    //макрос, компилятор заменяет все слова на 0 
    pa = NULL;
    //избавляем о том что бы случайно записать не те данные, должно использоваться с null
    if (pa != NULL)
    {
        cout << pa << endl;
    }
```

Комплилятор никогда не перепутает int 0 и nullptr. При перегрузке функции, когда можно ввести несколько значений для  функции и что он никогда не перепутал с int 0. 

Всегда лучше использовать nullptr с указателем. 

Всегда нужно в начале удалять данные, потом присваивать nullptr. Иначе мы затираем адрес до данные, но очищаем данные 

## Динамический массив. Создание, заполнение, удаление, размер динамического массива 

Задается размер динамического массива можем установить на ходу действия программы 

Размер указываем как переменную, а не константу 

Оператор new - указатель на массив 

```cpp
void main() 
{
    int size = 5; 
    int *arr = new int[size];
    for (int i = 0; i < size; i++)
    {
        cout << arr[i] << "\t";

        //с помощью арифметики указателей
        cout << arr + i << endl; 

        //с помощью арифметики указателей
        cout << *(arr + i) << endl; 
    }

    delete [] arr;
}
```

-842150451      00B72AB8
-842150451      00B72ABC
-842150451      00B72AC0
-842150451      00B72AC4
-842150451      00B72AC8

```cpp
#include <iostream>
using namespace std;

void main() 
{
    int size = 0; 
    cout << "Enter array size" << endl;
    cin >> size;

    int *arr = new int[size];

    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 10;
    }

    for (int i = 0; i < size; i++)
    {
        cout << arr[i] << "\t";

        //с помощью арифметики указателей
        cout << arr + i << endl; 
    }

    delete [] arr;
}
```

Enter array size
10
1       0144B660
7       0144B664
4       0144B668
0       0144B66C
9       0144B670
4       0144B674
8       0144B678
8       0144B67C
2       0144B680
4       0144B684

![[Pasted image 20250102092943.png]]

Используя арифметику указателей можно попасть в любую область памяти. Необходимо быть аккуратным. Так как можно получить неизвестные значения. 

![[Pasted image 20250102093420.png]]

## Двумерный динамический массив. Создание, заполнение, удаление. 

Двумерный массив - одномерный массив, одномерных массивов. Где каждый элемент содержит, вместо переменных себе указатель на массив. Который содержит переменную или указатель на другой массив. Это уже 3 мерный массив.  и тд. 


Одномерный массив, одномерных массивов. 

![[Pasted image 20250102104451.png]]

Вертикальный массив - это строчка. Сначала мы должны указать номер массив строчки. А затем элемент из других массивах 

![[Pasted image 20250102104851.png]]

После того как мы создадим массив rows. Мы будем итерироваться и в каждую ячейку присваивать указатель, который указывает на другой динамический массив и этот массив будет содержать такое количество элементов, какой содержит переменная cols. 

```cpp
#include <iostream>
using namespace std;

//** переменная хранит указатель на указатель

void main()
{

    int rows = 4;
    int cols = 5;

    //создание массива 
    int **arr = new int *[rows];
    for (int i = 0; i < rows; i++)
    {
        arr[i] = new int[cols];
    }

    //работа массива 
    for (int  i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            arr[i][j] = rand() % 20;
        }
    }

    //вывод массива
    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            cout << arr[i][j] << "\t";
        }
        cout << endl; //переход на след строчку
    }

    //очищение оперативной памяти, после созданий массивов
    for (int i = 0; i < rows; i++)
    {
        delete[] arr[i];
    }
    delete[] arr;
}
```

```
1       7       14      0       9
4       18      18      2       4
5       5       1       7       1
11      15      2       7       16
```

![[Pasted image 20250102110231.png]]

Заполняются в начале rows, затем cols. По каждой строке 

![[Pasted image 20250102110414.png]]

Кастомное введение rows and cols 

```cpp
    int rows;
    int cols;

    cout << "enter rows" << endl;
    cin >> rows;
    cout << "enter cols" << endl;
    cin >> cols;
```

## Константные аргументы функции. Константный указатель. 

Параметры переданные в функцию, становятся константами. Внутри функции с этими параметрами ничего нельзя сделать. А значит что данные не будут обработаны будут не корректно. 

Например параметр size поделится на 2 и заполнится не весь массив 

```cpp
void FillArray(int *const arr, const int size) 
{
    //size = 1; нельзя 
    //arr = new int[10]; не может работать из константы 
    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 10;
    }
}	

void ShowArray(const int *const arr, const int size) 
{
    for (int i = 0; i < size; i++)
    {
        cout << arr[i] << "\t";
    }
    cout << endl;
}

void main()
{
}
```

## Как скопировать динамический массив 

Не правильный способ копирования, делает два указателя на один и тот же массив 

![[Pasted image 20250103104214.png]]

```cpp
#include <iostream>
using namespace std;

void FillArray(int *const arr, const int size) 
{
    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 10;
    }
}	

void ShowArray(const int *const arr, const int size) 
{
    for (int i = 0; i < size; i++)
    {
        cout << arr[i] << "\t";
    }
    cout << endl;
}

void main()
{
    int size = 10;
    int *FirstArray = new int[size];
    int *SecondArray = new int[size];
    
    FillArray(FirstArray, size);
    FillArray(SecondArray, size);

    cout << "FirstArray = \t";
    ShowArray(FirstArray, size);
    cout << "SecondArray = \t";
    ShowArray(SecondArray, size);

    FirstArray = SecondArray;

    cout << "=============================" << endl;

    cout << "FirstArray = \t";
    ShowArray(FirstArray, size);
    cout << "SecondArray = \t";
    ShowArray(SecondArray, size);

    delete[] SecondArray;
    delete[] FirstArray;
}
```

при такой записи создается не копия, а один массив берет ссылку другого и теперь два массива будут указывать на один и тот же массив

![[Pasted image 20250103103812.png]]

При вызове delete будет ошибка, так как ему надо удалять 2 раза один и тот же массив 

```
    delete[] SecondArray;
    delete[] FirstArray;
```

![[Pasted image 20250103104028.png]]

Такая ошибка выходит при удалении два раза массива, который уже удален wntdll.pdb 

![[Pasted image 20250103104104.png]]

Правильный способ копирования 

![[Pasted image 20250102150644.png]]

```cpp
#include <iostream>
using namespace std;

void FillArray(int *const arr, const int size) 
{
    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 10;
    }
}	

void ShowArray(const int *const arr, const int size) 
{
    for (int i = 0; i < size; i++)
    {
        cout << arr[i] << "\t";
    }
    cout << endl;
}

void main()
{
    int size = 10;
    int *FirstArray = new int[size];
    int *SecondArray = new int[size];
    
    FillArray(FirstArray, size);
    FillArray(SecondArray, size);

    cout << "FirstArray = \t";
    ShowArray(FirstArray, size);
    cout << "SecondArray = \t";
    ShowArray(SecondArray, size);

    //удаляем массив 1 
    delete[] FirstArray;

    //выделяем место в памяти под новый массив 
    FirstArray = new int[size];
    for (int i = 0; i < size; i++)
    {
        //переносим каждый элемент массива один  в другой 
        FirstArray[i] = SecondArray[i];
    }

    cout << "=============================" << endl;

    cout << "FirstArray = \t";
    ShowArray(FirstArray, size);
    cout << "SecondArray = \t";
    ShowArray(SecondArray, size);

    delete[] FirstArray;
    delete[] SecondArray;
}
```

```
FirstArray =    1       7       4       0       9       4       8       8       2       4
SecondArray =   5       5       1       7       1       1       5       2       7       6
=============================
FirstArray =    5       5       1       7       1       1       5       2       7       6
SecondArray =   5       5       1       7       1       1       5       2       7       6
```

Для того что бы понять что создалась копия можно сравнить адреса массивов, они разные 

![[Pasted image 20250103104912.png]]

## Изменить размер массива. Удалить, добавить элемент в массив. Увеличение массива 

Массив - непрерывная последовательность ячеек. 

Что бы изменить массив и добавить ячейки. Нужно создать новый массив с новыми ячейками Перенести туда данные и перенести указатель на этот массив. Старый массив удалить. 

![[Pasted image 20250103105506.png]]

Удаление ячеек. Пересоздать массив и перенести туда данные. 

![[Pasted image 20250103105907.png]]

Вот эта штука "*&" называется неконстантная ссылка. Она должна ссылаться на указатель, поскольку его адрес можно изменять. И вот с её помощью можно делать то же, что и с указателем, только она работает не напрямую с тем, на что ссылается, а через адрес другого указателя. И поэтому с помощью такой штуки можно еще и заодно изменить адрес другого указателя. Это кто не понял

```cpp
#include <iostream>
using namespace std;

void FillArray(int *const arr, const int size)
{
    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 10;
    }
}

void ShowArray(const int *const arr, const int size)
{
    for (int i = 0; i < size; i++)
    {
        cout << arr[i] << "\t";
    }
    cout << endl;
}

/*

стандартизированная функция, которая добавлят в конец массива элемент
value - значение, которое мы хотим добавить в конец
size - размер массива, по ссылке и не константу. что бы иметь возможность увеличивать
arr - *&указатель на ссылку, дает возможность подменить массиву адрес, что бы он указывал на новый
адрес указателя, который указывает на динамический массив

Передача указателя по ссылке нужна, что бы не создавался новый указатель, а брался по ссылке. 

 */

void push_back(int *&arr, int &size, const int value)
{
    int *newArray = new int[size + 1];
    for (int i = 0; i < size; i++)
    {
        newArray[i] = arr[i];
    }
    //передаем в самую последнюю ячейку данные 
    newArray[size] = value;

    //увелечение размера 
    size++;

    //стираем старые данные
    delete[] arr;

    //переносим адрес в памяти  на новый массив
    arr = newArray;
}

//фукнция удаление последнего элемента 
void pop_back(int*& arr, int& size)
{
    //в начале сразу уменьшаем размерность массива на единицу, что бы при создании он уже был меньше 
    size--;
    int *newArray = new int[size];
    for (int i = 0; i < size; i++)
    {
        newArray[i] = arr[i];     
    }

    //стираем старые данные
    delete[] arr;

    //переносим адрес в памяти  на новый массив
    arr = newArray;
}

//добавление в начало 
void push_start(int *&arr, int &size, const int value) 
{
    //увелечение размера
    size++;
    int *newArray = new int[size + 1];
    for (int i = 1; i < size; i++)
    {
        newArray[i] = arr[i-1];
    }

    //передаем в первую ячейку данные
    newArray[0] = value;

    //стираем старые данные
    delete[] arr;

    //переносим адрес в памяти  на новый массив
    arr = newArray;
}

//удаление из начала
void pop_start(int *&arr, int &size)
{
    //в начале сразу уменьшаем размерность массива на единицу, что бы при создании он уже был меньше
    size--;
    int *newArray = new int[size];
    for (int i = 0; i < size; i++)
    {
        newArray[i] = arr[i+1];
    }

    //стираем старые данные
    delete[] arr;

    //переносим адрес в памяти  на новый массив
    arr = newArray;
}

//добавление по индексу
//есть недоработка, если записывать в последнее число, которое как бы не должно существовать. так же можно записать в число, которое не в массиве. но оно не будет показано 
void push_index(int *&arr, int &size, const int value, const int index)
{
    //увелечение размера
    size++;
    bool IndexGone = false;
    int *newArray = new int[size + 1];
    for (int i = 0; i < size; i++)
    {
        //проверка прошел ли индекс, что бы начать вставлять число, которое занял индекс 
        if (IndexGone == true)
        {
            newArray[i] = arr[i - 1];
        }
        else
        {
            if (i == index)
            {
                newArray[i] = value;
                IndexGone = true;
            }
            else
            {
                newArray[i] = arr[i];
            }
        }
    }

    //передаем в первую ячейку данные
    //newArray[index] = value;

    //стираем старые данные
    delete[] arr;

    //переносим адрес в памяти  на новый массив
    arr = newArray;
}

//удаление по индексу 
void pop_index(int *&arr, int &size, const int index)
{
    //уменьшение размера
    size--;
    bool IndexGone = false;
    int *newArray = new int[size];
    for (int i = 0; i < size; i++)
    {
        //проверка прошел ли индекс 
        if (i == index || IndexGone == true)
        {
            IndexGone = true;
            if (IndexGone == true)
            {
                //пропуск числа под индексом 
                newArray[i] = arr[i + 1];
            }
        }
        else
        {
            newArray[i] = arr[i];
        }
    }

    //стираем старые данные
    delete[] arr;

    //переносим адрес в памяти  на новый массив
    arr = newArray;
}


void main()
{
    int size = 5;
    int *arr = new int[size];

    cout << "Fill and Show array" << endl;
    FillArray(arr, size);
    ShowArray(arr, size);
    cout << endl;

    cout << "push back" << endl;
    push_back(arr, size, 111);
    ShowArray(arr, size);
    cout << endl;

    cout << "pop back" << endl;
    pop_back(arr, size);
    ShowArray(arr, size);
    cout << endl;

    cout << "push start" << endl;
    push_start(arr, size, 31);
    ShowArray(arr, size);
    cout << endl;

    cout << "pop start" << endl;
    pop_start(arr, size);
    ShowArray(arr, size);
    cout << endl;

    int index = 3;
    cout << "push index = " << index << endl;
    push_index(arr, size, 45, index);
    ShowArray(arr, size);
    cout << endl;

    int indexDelete = 3;
    cout << "pop index = " << indexDelete << endl;
    pop_index(arr, size, indexDelete);
    ShowArray(arr, size);
    cout << endl;

    delete[] arr;
}
```

```
Fill and Show array
1       7       4       0       9

push back
1       7       4       0       9       111

pop back
1       7       4       0       9

push start
31      1       7       4       0       9

pop start
1       7       4       0       9

push index = 3
1       7       4       45      0       9

pop index = 3
1       7       4       0       9
```

## Строки. Нуль терминатор. Char 

Строки как тип данных нет. 
Строка где что то записано, это массив char'ов
В конце строки всегда должен быть символ \0 - нуль терминатор. Что бы понимать где конец строки

![[Pasted image 20250106224717.png]]

```cpp
void main()
{
    //'2' 'b' '$' может хранить только одно значение. Символ. 
    //"" присваивается строка 
    char symbol = 'q';
    cout << symbol << endl;
    // strlen  функция считает все до нуль терминатора. Выводя колличество символов 
}
```

![[Pasted image 20250106225220.png]]

```cpp
    //вывод строчки
    char string [] = "Hello World!";
    cout << string << endl;

    //вывод посимвольно 
    char string[] = {'H', 'e', 'l', 'l', 'o', '\0'};
    cout << string << endl;

    //вывод количество символов = 5
    char string[] = {'H', 'e', 'l', 'l', 'o', '\0'};
    cout << strlen(string) << endl;
```

## Приведение типов в стиле с. Явное и неявное представление типов. Преобразование типов

```cpp
void main()
{
    double a = 33.3;

    //(типа_данных)перменная 
    //(int)a
    
    //(bool)a
    //if bool = 0, bool = false
    //if bool >0, bool = true 

    cout << (char)a << endl;
}
```

```cpp
    //явное преобразование 
    cout << (double)a << endl;

    //не явное преобразование 
    int b = 35.5151;
    cout << b << endl; //вывод 35 
```

double больше чем int. поэтому мы не потеряем числа из int в double 

Комплиятор присваивает к наиболее большому числу, вмещающий в себя все. 

## Что такое ASCII символы. "аски"

```cpp
void main()
{
    setlocale(LC_ALL, "ru");

    //какой код какое char соответствует 
    for (int i = 0; i <= 255; i++)
    {
        cout << "code = " << i << "\t"<< "char = " << (char)i << endl;
     }
}
```

0 - 127 всегда статические символы. Английская стандартная клавиатура 
Все что идет дальше это setlocale 

## Указатели символьные строки и функции. Строки и указатели 

```cpp
void main()
{
    const char *string = "Hello"; //используем const так как указатель на массив константный 

	//можно записать еще так 
    char *str = new char[]{"Hello"};
    char str[] = "Hello";
    const char *str = "Hello";

    cout << string << endl; 
}
```

```cpp
void main()
{
    char str[] = "Hello";

    const char *string = str;  

    cout << string << endl; 
}
```

```cpp
void main()
{
    const char *strArr[] = {"Hello", "World", "Test"};

    for (int i = 0; i < 3; i++)
    {
        cout << strArr[i] << endl;
    }
}
```

```cpp
void foo(const char* str)
{
    cout << strlen(str) << endl;
}

void main()
{
    const char *str = "Hello";
    foo(str);
}
```

Счетчик кастомный
```cpp
int Strlength(const char* str)
{
    int counter = 0;

    while (str[counter] != '\0')
    {
        counter++;
    }

    return counter;
}

void main()
{
    const char *str = "Hello";
    
    cout << Strlength(str) << endl;
}
```

## Конкотенация строк. Объединение строк. Тип данных string c++

Объединение каких то элементов в новый элемент. 

В стиле С

```cpp
#include <iostream>
using namespace std;

void main()
{
    char result[255]{}; //инициализация пустого массива 
    char str1[255] = "Hello";
    char str2[255] = "World";

    cout << str1 << endl;
    

    //помещение строк в одну 
    strcat_s(result, str1);
    strcat_s(result, str2);


    cout << result << endl;
}
```

```cpp
#include <iostream>

//добавление класса string 
#include <string>
using namespace std;

void main()
{
    string str1 = "Hello";
    string str2 = "World";
    string result;

    result = str1 + " " + str2; 

    cout << result << endl;
}
```

## Указатель на функцию в качестве параметра 

Указатель на функцию - это переменная куда мы можем засунуть функцию или присвоить туда функцию и потом из такой же переменной эту функцию вызвать.

```cpp
#include <iostream>
using namespace std;

//синтаксис 
//тип функции (*имя указателя)(спецификация параметров);

void Foo1()
{
    cout << "void Foo 1()" << endl;
 }

void Foo2() 
{
    cout << "void Foo 2()" << endl;
}

void main()
{
    //мы создали указатель, в которую мы можем присвоить адрес функции, которая возвращает void и не принимает никаких параметров 
    void (*fooPointer)();

    fooPointer = Foo1;

    fooPointer();
}
```

Вывод
void Foo 1()
``
```cpp
#include <iostream>
using namespace std;

//синтаксис 
//тип функции (*имя указателя)(спецификация параметров);

int Foo1(int a)
{
    return a - 1;
 }

int Foo2(int a) 
{
    return a * 2;
}

void main()
{
    int (*fooPointer)(int a );

    fooPointer = Foo1;

    cout << fooPointer(5) << endl;
}
```

С помощью указателя на функции. Если у вас есть несколько разных функция и одна функция для их вывода можно в функции для выводу указать данные, которые она должна получать из указанной функции и указать эту функцию. Дальше будет не важно какая из функция это будет, так как она будет указана названием и не нужно будет делать дерево if что бы вызывать определенную функцию. 

```cpp
#include <iostream>
#include <string>
using namespace std;

//синтаксис 
//тип функции (*имя указателя)(спецификация параметров);

string GetDataFromBD() 
{
    return "Data From BD";
}

string GetDataFromWebServer()
{
    return "Data From WebServer";
}

string GetDataFromAstral()
{
    return "Data From Astral";
}

void ShowInfo(string (*foo)()) 
{
    cout << foo() << endl;
}

void main()
{
    ShowInfo(GetDataFromAstral);
}
```

Вывод
Data From Astral

## Препроцессор. Директива #define. Макросы 

Препроцессор - программа, которая которая работает с кодом, перед тем как он скомпилируется 

```
#include - директива препроцессора 

говорит что вот есть код в файлике и перед тем как компилировать, допиши вот этот код сюда в начало 
```

можно читать как "определить"
симпволы которые мы укажем, она заменит на символы которые мы ей укажем 
С помощью нее можно указывать макросы 
#define 

```cpp
#include <iostream>
#define PI 3.14
using namespace std;

void main()
{
    cout << PI << endl;
}
```

Директива до компиляции пробежится по всему коду и заменит все PI на 3.14. то есть будет так 

```cpp
void main()
{
    cout << PI << endl;
	PI 
	PI
	PI
}

Компилятор увидит это как 

void main()
{
    cout << 3.14 << endl;
	3.14
	3.14
	3.14
}
```

```cpp
#include <iostream>
#define PI 3.14
#define tab "\t"
using namespace std;

void main()
{
    cout << "text" << tab << "text" << endl;
}
```

text    text

Можно сделать так. Но это может быть опасно, так как если есть функции или названия с такой же переменной, то она заменит их всех на то то указано в #define 

```cpp
#include <iostream>
#define PI 3.14
#define tab "\t"
#define begin {
#define end }
using namespace std;

void main()
{
    for (size_t i = 0; i < length; i++)
    begin

    end
}
```

функция begin может превратить в {()

## Макрос функции. Макросы с аргументами. Макросы с параметрами 

Функция в виде макроса 

```cpp
#include <iostream>
//((x)*(y)) это так же как написать return, это возвращение фукнции 
#define FOO(x,y) ((x)*(y))
using namespace std;

void main()
{
    cout << FOO(5, 6) << endl;
}
```

## Условная компиляция. Директивы #ifdef #else #endif #if #elif #endif #ifdef 

Если опредлен DEBUG в начале, то все что в определении #ifdef будет работать 

```cpp
#include <iostream>
using namespace std;
//определить ДЕБАГ
//#define DEBUG
#define DEBUG

void main()
{
    setlocale(LC_ALL, "ru");

//if define the bug . Если определен ДЕБАГ
#ifdef DEBUG
    cout << "начало цикла" << endl;
#endif //DEBUG

    for (int i = 0; i < 4; i++)
    {
        cout << i << endl;
    }

#ifdef DEBUG
    cout << "дебаг определен" << endl;
#else 
    cout << "дебаг НЕ определен" << endl;
#endif // DEBUG

}

```

Есть так же #ifndef он работает так же, только на оборот 

```cpp
#ifndef DEBUG
    cout << "cout 1" << endl;
#else 
    cout << "cout 2" << endl;
#endif // DEBUG
```

Можно определять как #if 

```cpp
#include <iostream>
using namespace std;
#define DEBUG 5 

void main()
{
    setlocale(LC_ALL, "ru");

#if DEBUG > 4
    cout << "cout 1" << endl;
#elif DEBUG == 5 
    cout << "cout 2" << endl;
#endif // DEBUG
}
```

## Условный тернарный оператор. 

```cpp
   if (a < 10)
    {
        cout << "а меньше 10" << endl;
    }
    else
    {
        cout << "а больше 10" << endl;
    }
```

два вида кода можно понять в разных понятиях, один и тот же код можно написать в строчку 

```cpp
#include <iostream>
using namespace std;

void main()
{
    setlocale(LC_ALL, "ru");
    
    int a;
    cin >> a;

    (a < 10) ? cout << "а меньше 10" << endl : cout << "а больше 10" << endl;
}
```

С еще большим количеством условий 

```cpp
    if (a < 10)
    {
        cout << "а меньше 10" << endl;
    }
    else
    {
        if (a > 10)
        {
            cout << "а больше 10" << endl;
        }
        else 
        {
            cout << "а равна 10" << endl;     
        }
    }
```

```cpp
#include <iostream>
using namespace std;

void main()
{
    setlocale(LC_ALL, "ru");
    
    int a;
    cin >> a;

    (a < 10) ? (cout << "а меньше 10" << endl) : (a > 10) ? (cout << "а больше 10" << endl) : (cout << "а равна 10" << endl);
}
```

## Argc, Argv. Параметры функции 

В зависимости от того какой параметр получит программа, можно реализовать метод ее работы 

argument count - количество аргументов 
argument values - массив, содержит строк. описание команд 

первый элемент всегда хранит в себе путь к исполняемому файлу 

```cpp
#include <iostream>
using namespace std;

void main(int argc, char* argv[])
{
    for (int i = 0; i < argc; i++)
    {
        cout << argv[i] << endl;
    }
}
```

Можно передать параметры 

![[Pasted image 20250226114202.png]]
![[Pasted image 20250226114216.png]]

## Int main или void main

int main имеет возможность возвращать return 0 и при удачном компилировании модуля. Объект который вызвал этот модуль получает возвращенное значение 0. Так он понимает что модуль скомпилирован нормально. 
 
Стандарт разработки 

```cpp
int main()
{

	return 0;
}
```


void main ничего не возвращает. И для main такое написание не правильное, так можно написать только в Visual Studio. 

```
void main()
{

}
```

## Что такое ООП

Объекто Ориентированное Программирование 

Методы - свойства, которые описаны по шаблону и у которых есть каких то функции. Методы с помощью которых мы может взаимодействовать с объектом 

Пример. Кофемолка - молоть кофе 

Инкапсуляция - принцип независимости данных. То есть программист может скрыть некоторые функции, которые служат для работы программы. И оставить только внешние элементы управления, с помощью которых использует программу. На примере кофемолки, мы можем засыпать зерна и молоть зерна. Но мы не можем вляить на скорость вращения лопастей, наклон и тд. 

Наследование - процесс, один объект который может наследовать методы другого объекта и дополнять своим функционалом. Например кофемашина, мы может наследовать от кофемолки. Кофемашина получает метод молоть кофе. Взаимодействовать специфическим образом. 

Полиморфизм - методы, одинаковые, но выполняться на разных объектах будут по разному. Реализация скрыта, но интерфейс один и тот же. Двигатель фуры и двигатель машины.  Класс постройка от нее есть шахта, печь и метод производить. И у всех разные реализации. Все функции реализуются скрыто. 

**Основные различия между объектно-ориентированным программированием (ООП) и функциональным программированием**:

1. **Парадигма**. ООП основано на концепции объектов и классов, в то время как функциональное программирование основано на концепции функций. [1](https://dzen.ru/a/ZZQyqbChZQJnGwZq)
2. **Состояние**. В ООП объекты имеют состояние, которое может изменяться с помощью методов. В функциональном программировании функции не имеют состояния и должны быть «чистыми». [1](https://dzen.ru/a/ZZQyqbChZQJnGwZq)
3. **Изменяемость**. В ООП объекты могут быть изменяемыми, что означает, что их состояние может изменяться. В функциональном программировании данные обычно являются неизменяемыми, и изменение данных создаёт новые версии. [1](https://dzen.ru/a/ZZQyqbChZQJnGwZq)
4. **Подход к решению задач**. В ООП акцент делается на моделировании реального мира с помощью объектов и их взаимодействия. В функциональном программировании акцент делается на преобразовании данных с помощью функций. [1](https://dzen.ru/a/ZZQyqbChZQJnGwZq)
5. **Параллелизм**. Функциональное программирование обычно лучше подходит для параллельного и распределённого программирования, так как функции не имеют состояния и не зависят от внешних факторов. [1](https://dzen.ru/a/ZZQyqbChZQJnGwZq)

Получается что все 3 работают вместе и истекают друг из друга. Работают вместе. Так инкапсуляция есть во всех child'ах. Из parent можно наследовать, добавить туда новые функции. В другом child если с виду один и тот же метод назван одинаково, но кодом программистом прописано, что если ему следует действовать по другому, то метод внешне с теми же настройками, будет работать по другому. 

![[Pasted image 20250302173741.png]]

## Что такое класс. Что такое объект класса. Экземпляр класса. 

Класс - это пользовательский класс. Тип даннных который можно написать самому. Не возвращает никаких значений 

Можно использовать другие класса как типы данных. 

Что бы обратиться к полям и методам класса, которые в нем есть. Нужно написать название класса и поставить точку. 

```cpp
#include <iostream>
#include <string>
using namespace std;

//описывает шаблон класса 
//здесь описываются методы класса 
// 
//у каждого человека есть свои методы. Это возраст, имя, вес и др. 

class Human
{
public:

    int age;
	string name;
	
};

int main()
{
	//создаем объект класса 
	// int a; почти так же. human - это кастомный тип данных

    Human FirstHuman;

	//есть тип данных человека, который может хранить в себе несколько данных. возраст и имя 
	FirstHuman.age = 30;
    FirstHuman.name = "Ivanov Ivan Ivanovich";

	cout << FirstHuman.age << endl;
    cout << FirstHuman.name << endl;

	return 0;
}
```

30
Ivanov Ivan Ivanovich

```
FirstHuman.age
```

![[Pasted image 20250226141741.png]]

```cpp
#include <iostream>
#include <string>
using namespace std;

//описывает шаблон класса
//здесь описываются методы класса
//
//у каждого человека есть свои методы. Это возраст, имя, вес и др.

class Human
{
public:
    int age;
    int weight;
    string name;
};

int main()
{
    //создаем объект класса
    // int a; почти так же. human - это кастомный тип данных

    Human FirstHuman;

    FirstHuman.age = 30;
    FirstHuman.age = 30;
    FirstHuman.name = "Ivanov Ivan Ivanovich";
    FirstHuman.weight = 100;

    cout << FirstHuman.age << endl;
    cout << FirstHuman.name << endl;
    cout << FirstHuman.weight << endl;

    cout << "___________________________________" << endl;

    Human SecondHuman;

    SecondHuman.age = 19;
    SecondHuman.name = "NoName";
    SecondHuman.weight = 60;

    cout << SecondHuman.age << endl;
    cout << SecondHuman.name << endl;
    cout << SecondHuman.weight << endl;


    return 0;
}

```

30
Ivanov Ivan Ivanovich
100
___________________________________
19
NoName
60

```cpp
class Point
{
public:

    int x;
    int y;
    int z;

};

int main()
{
    Point a;

    a.x = 1;
    a.y = 3;
    a.z = 5;

    return 0;
}
```

![[Pasted image 20250226143903.png]]

## Метода класса. Вызов метода класса. 

Методы класса и функции класса, это одно и тоже. И реализация такая же как и функции. 

```cpp
#include <iostream>
#include <string>
using namespace std;

class Human
{
public:
    int age;
    int weight;
    string name;

    void Print()
    {
        cout << "Имя " << name << "\nВес " << weight << "\nВозраст " << age << endl << endl;
    }
};

class Point
{
public:
    int x;
    int y;
    int z;
};

int main()
{
    setlocale(LC_ALL, "ru");

    Human FirstHuman;

    FirstHuman.age = 30;
    FirstHuman.name = "Ivanov Ivan";
    FirstHuman.weight = 100;
    
    FirstHuman.Print();

    //у каждого экземпляра свои поля класса 
    Human SecondHuman;
    
    SecondHuman.Print();

    return 0;
}
```

Имя Ivanov Ivan
Вес 100
Возраст 30

Имя
Вес -858993460
Возраст -858993460

## Модификаторы доступа классов. Public . Private . Protected . Спецификаторы доступа 

По умолчанию модификатор доступа для класса всегда стоит private. Класс Private открыт только самому классу и методам этого класса или дружественным методам класса и функций. 

Private - всегда закрыт

```cpp
class Point
{
private:
    int x;
    int y;
};

int main()
{
    Point a;
    a.??? //поэтому тут мы не сможем вызвать поле или метод x или y 

    return 0;
}
```

Public - всегда открыт 

```cpp
class Point
{
public:
    int x;
    int y;
};

int main()
{
    Point a;
    a.x

    return 0;
}
```

![[Pasted image 20250226153449.png]]

```cpp
class Point
{
public: //все что ниже он будет считать public, до тех пор пока не встретит private. Даже если нет private 
    int x;
    int y;

private: 
    int z;
};
```

Protected. Пока ничем не отличается от private. Но мы можем получить доступ к полю через наследование. 

```cpp
class Point
{
public: //все что ниже он будет считать public, до тех пор пока не встретит private. Даже если нет private 
    int x;

protected: 
    int y;
    int z;
};

int main()
{
    Point a;
    a.

    return 0;
}
```

![[Pasted image 20250226153744.png]]

Когда мы находимся в классе и взаимодействует с переменными, которые находятся в одном классе, можем взаимодействовать с друг с другом. 
Но выйдя из класса и вызвав класс, мы сможем взаимодействовать только с тем, что указано в классе в графе public. 

```cpp
#include <iostream>
#include <string>
using namespace std;

class Human
{
public:
    int age;
    int weight;
    string name;

    void Print()
    {
        cout << "Имя " << name << "\nВес " << weight << "\nВозраст " << age << endl
             << endl;
    }
};

class Point
{
public: //доступно для вызова везде
    int x;
    void PrintPublic()
    {
        cout << "y = " << y << "\nx= " << x << "\nz= " << z << endl;
        PrintPrivate(); //но мы можем вызвать из private 
    }

private: //доступно только внутри класса и для дружественных
    int y;
    int z;

    void PrintPrivate() //метод будет недоступен
    {
        cout << "y = " << y << "\nx= " << x << "\nz= " << z << endl;
        PrintPublic(); //это можно увидеть везде 
    }
};

int main()
{
    Point a;
    a.PrintPublic();
    //a.PrintPrivate(); ОШИБКА, не сможет найти так как он в private 

    return 0;
}
```

## Геттеры и сеттеры. Методы Get / Set . Инкапсуляция это 

Данные были отделены от методов. Переменные были отделены от функций класса. 

Предоставлять доступ к прямым свойствам класса. Не принято. Нарушает принцип инкапсуляции. 

```cpp
#include <iostream>
#include <string>
using namespace std;

class Point
{
private:
    int x;
    int y;

public:
    //Все что можно получить, необходимо писать начиная с Get
    int GetX()
    {
        return x;
    }

    int GetY()
    {
        return y;
    }

    //Методы Set 
    void SetX(int ValueX)
    {
        x = ValueX;
    }

    void SetY(int ValueY)
    {
        y = ValueY;
    }

    //Другие методы 
    void Print()
    {
        cout << "X= " << x << "\t Y= " << y << endl << endl;
    }
};

int main()
{
    Point a;
    a.SetX(5);
    a.SetY(20);

    a.Print();

    int result = a.GetY();
    cout << result << endl;

    return 0;
}
```

## Инкапсуляция ООП пример. Private методы

Перед включением кофемашины, должна пройти скрытая проверка на напряжение. Это проверка будет скрыта внутри от пользователя и по ее результату, будет работа кофемашины 

```cpp
class CoffeeGrinder
{
private:
    bool CheckVoltage()
    {

        return false;
    }

public:
    void Start() 
    {
        if (CheckVoltage())
        {
            cout << "Vsjuh!" << endl;     
        }
        else
        {
            cout << "Beep Beep" << endl;
        }

    }

};

int main()
{
    CoffeeGrinder a;
    a.Start();

    return 0;
}

```

## Конструктор класса в ООП. Конструктор с параметрами. Конструктор умолчанию. 

Конструктор должен быть в public секции и называется так же как сам класс. 

```cpp
public:
    //Конструктор по умолчанию 
    Point() 
    {
        
    }
```

```cpp
#include <iostream>
#include <string>
using namespace std;

class Point
{
private:
    int x;
    int y;

public:
    //Конструктор класса. Он есть всегда. Даже если его нет, он существует по умолчанию.
    Point(int ValueX, int ValueY)
    {
        x = ValueX;
        y = ValueY;
    }

    //Все что можно получить, необходимо писать начиная с Get
    int GetX()
    {
        return x;
    }

    int GetY()
    {
        return y;
    }

    //Методы Set
    void SetX(int ValueX)
    {
        x = ValueX;
    }

    void SetY(int ValueY)
    {
        y = ValueY;
    }

    //Другие методы
    void Print()
    {
        cout << "X= " << x << "\t Y= " << y << endl
             << endl;
    }
};

int main()
{
    Point a(5, 44);

    a.Print();

    Point b(55, 12);
    b.Print();

    return 0;
}
```

## Перегрузка конструктора класса

Это проявление полиморфизма в ООП. Так как в зависимости от того как мы создали класс с помощью какого конструктора, то он будет себя по разному вести. 

Для перегрузки конструктора главное это что бы отличались количеством принимаемых параметров и их типами. 

```cpp
public:
    //Конструктор по умолчанию 
    Point() 
    {
        x = 0;
        y = 0;
    }  

    //Конструктор класса. Он есть всегда. Даже если его нет, он существует по умолчанию.
    Point(int ValueX, int ValueY)
    {
        x = ValueX;
        y = ValueY;
    }
```

Если написать так комментарий. То при перегрузки конструктора он будет высвечиваться. 

```cpp
    //Конструктор класса. Он есть всегда. Даже если его нет, он существует по умолчанию.
    Point(int ValueX, int ValueY)
    {
        x = ValueX;
        y = ValueY;
    }
```

![[Pasted image 20250227155709.png]]

## Деструктор. Деструктор по умолчанию 

Специальная функция, мы вызвать его конкретно не можем. Он вызывается сам. Разрушение объекта происходит, когда он выходит из зоны видимости. 

Если создавался какой то объект, то при выходе из зоны видимости он будет разрушаться для освобождения места для компьютера. Разрушаться он будет с помощью деструктора. 

![[Pasted image 20250227160835.png]]

Деструктор всегда один. Он может быть написан, может быть нет и будет по умолчанию. 
Деструктор никак не может иметь параметры

Создается класс 
Вызывается конструктор 
Идет код 
Выход из области видимости и разрушение объекта класса 
Вызывается деструктор 

Объекты уничтожаются в обратном порядке того, как они были созданы 

```cpp
class MyClass
{
    int data;

public:
    //Конструктор
    MyClass(int value)
    {
        data = value;
        cout <<"Объект " << data << " Вызывался конструктор" << endl;
    }

    //Деструктор. Всегда только один. 
    ~MyClass()
    {   
        cout << "Объект " << data << " Вызывался деструктор" << endl;
    }
};

int main()
{
    setlocale(LC_ALL, "ru");
    MyClass a(1);

    MyClass b(2);

    return 0;
}
```

Объект 1 Вызывался конструктор
Объект 2 Вызывался конструктор
Объект 2 Вызывался деструктор
Объект 1 Вызывался деструктор

```cpp
class MyClass
{
    int data;

public:
    //Конструктор
    MyClass(int value)
    {
        data = value;
        cout <<"Объект " << data << " Вызывался конструктор" << endl;
    }

    //Деструктор. Всегда только один. 
    ~MyClass()
    {   
        cout << "Объект " << data << " Вызывался деструктор" << endl;
    }
};

void Foo()
{
    cout << "Foo начало выполения" << endl;
    MyClass a(1);
    cout << "Foo конец выполнения" << endl;
}

int main()
{
    setlocale(LC_ALL, "ru");

    Foo();

    return 0;
}
```

Foo начало выполения
Объект 1 Вызывался конструктор
Foo конец выполнения
Объект 1 Вызывался деструктор

При работе с динамическим массивом. Мы можем пользоваться деструктором для освобождения ресурсов при создании класса. 

```cpp
class MyClass
{
    int* data;

public:
    //Конструктор
    MyClass(int size)
    {
        //в конструкторе класса вы выделяем место под какой то массив 
        data = new int[size];
        for (int i = 0; i < size; i++)
        {
            data[i] = i;
        }

        cout <<"Объект " << data << " Вызывался конструктор" << endl;
    }

    //Деструктор. Всегда только один. 
    ~MyClass()
    {   
        //уберегаем от утечки памяти для динамического массива 
        delete[] data;
        cout << "Объект " << data << " Вызывался деструктор" << endl;
    }
};

void Foo()
{
    cout << "Foo начало выполения" << endl;
    MyClass a(1);
    cout << "Foo конец выполнения" << endl;
}

int main()
{
    setlocale(LC_ALL, "ru");

    Foo();

    return 0;
}
```

Foo начало выполения
Объект 01554BD8 Вызывался конструктор
Foo конец выполнения
Объект 01554BD8 Вызывался деструктор

## Ключевое слово this

У нас существует класс. Из этого класса, создали два объекта. Под них компилятор выделил 2 места. У них вызвали один и тот же метод a.print();

Компилятор обращается к адресу объекта а и по тому адресу обращается к методу принт. Этот адрес хранит ключевое слово this. По сути this это указатель на самого себя. Знание объекта о том, где он находится. Мы можем использовать его только внутри класса, не можем использовать снаружи. 

```
a.print();
```

```cpp
class Point
{
private:
    int x;
    int y;

public:
    //Конструктор по умолчанию 
    Point() 
    {
        x = 0;
        y = 0;
        cout << this << " constructor" << endl;
    }  

    //Конструктор класса. Он есть всегда. Даже если его нет, он существует по умолчанию.
    Point(int ValueX, int ValueY)
    {
        x = ValueX;
        y = ValueY;
        cout << this << " constructor" << endl;
    }

	//print метод
}

int main()
{
    setlocale(LC_ALL, "ru");

    Point a;

    a.Print();

    Point b(5, 15);

    b.Print();

    return 0;
}
```

Указатель на объект в котором мы сейчас находимся 

![[Pasted image 20250227171637.png]]\

Вывод
00D5FC60 constructor
X= 0     Y= 0

00D5FC50 constructor
X= 5     Y= 15

Через ключевое поле this можно получить доступ ко всему функционала объекта. Он имеет такой синтаксис 

![[Pasted image 20250227172136.png]]

Или так 

![[Pasted image 20250227172229.png]]

Использование. Что мы хотим именно y который есть в объекте. Использовать и применить значение другого y к нему. 

![[Pasted image 20250227172958.png]]

Поменяли цвета, что бы понять какой используется. Что серый это новый игрик который нужно применить, который ввелся пользователем. 
То есть мы говорим, что бы использовал внутренний y и применил к нему y который ввелся пользователм. Так внутренний y поменяет значение. 

![[Pasted image 20250227173121.png]]

```cpp
    void SetY(int y)
    {
        //y = y; он так не поймет 
        //так как y будут в поле видимости и он будет считать что они присваиваются сами себе 

        this->y = y;
    }
    
int main()
{
    setlocale(LC_ALL, "ru");

    Point a;
    a.SetY(5);
    a.Print();

    return 0;
}
```

## Конструктор копирования. Когда вызывается. Копирование объектов по умолчанию. 

Или конструктор присвавания одного элемента значения другому. Необходимо сделать новое выделение памяти для нового объекта 

![[Pasted image 20250227205807.png]]

При работе с массивами и динамической памятью. Командой delete может удаляться область памяти, которая уже удалена, тем самым вызывая ошибку. Что бы этого не происходило, необходимо переписать конструктор копирования и сделать свой, который будет копировать каждый элемент в новый массив с ссылкой и удалять этот новый массив. Тем самым не удаляя один и тот же. 

```cpp
class MyClass
{
    int size;

public:
    int *data;

    //Конструктор
    MyClass(int size)
    {
        this->size = size;
        this->data = new int[size];
        for (int i = 0; i < size; i++)
        {
            data[i] = i;
        }
        cout << "Вызывался конструктор " << this << endl;
    }

    //Конструктор копирования. Принимаем по ссылке, что бы не копировать
    MyClass(const MyClass &other)
    {
        this->size = other.size;

        //При копировании создаем новый массив и туда по элементно скопировали данные

        this->data = new int[other.size];

        for (int i = 0; i < other.size; i++)
        {
            this->data[i] = other.data[i];
        }

        //this->data = other.data; по обычному вот так 
        cout << "Вызывался конструктор копирования" << this << endl;
    }

    //Деструктор. Всегда только один.
    ~MyClass()
    {
        //уберегаем от утечки памяти для динамического массива
        delete[] data;
        cout << "Объект " << data << " Вызывался деструктор" << endl;
    }
};

int main()
{
    setlocale(LC_ALL, "ru");

    MyClass a(10);
    MyClass b(a);

    return 0;
}
```

Вызывался конструктор 00D5FD24
Вызывался конструктор копирования00D5FD14
Объект 011F2C98 Вызывался деструктор
Объект 011F2A98 Вызывался деструктор

## Перегрузка операторов присваивания. ООП. а.оператор = 

    //тип оператора operator (какой оператор)

```cpp
class MyClass
{
    int size;

public:
    int *data;

    //Конструктор
    MyClass(int size)
    {
        this->size = size;
        this->data = new int[size];
        for (int i = 0; i < size; i++)
        {
            data[i] = i;
        }
        cout << "Вызывался конструктор " << this << endl;
    }

    //Конструктор копирования.
    MyClass(const MyClass &other)
    {   
        this->size = other.size;
        this->data = new int[other.size];

        for (int i = 0; i < other.size; i++)
        {
            this->data[i] = other.data[i];
        }

        cout << "Вызывался конструктор копирования" << this << endl;
    }

    //Деструктор. 
    ~MyClass()
    {
        //уберегаем от утечки памяти для динамического массива
        delete[] data;
        cout << "Объект " << data << " Вызывался деструктор" << endl;
    }
};
```

Два объекта будут ссылаться на одну область памяти. Поэтому при удалении области памяти два раза будет ошибка. 

```cpp
    MyClass a(10);

    MyClass b(2);

    a = b;
```

![[Pasted image 20250302175401.png]]

![[Pasted image 20250302201048.png]]

```cpp
class MyClass
{
    int size;

public:
    int *data;

    //Конструктор
    MyClass(int size)
    {
        this->size = size;
        this->data = new int[size];
        for (int i = 0; i < size; i++)
        {
            data[i] = i;
        }
        cout << "Вызывался конструктор " << this << endl;
    }

    //Конструктор копирования.
    MyClass(const MyClass &other)
    {   
        this->size = other.size;
        this->data = new int[other.size];

        for (int i = 0; i < other.size; i++)
        {
            this->data[i] = other.data[i];
        }

        cout << "Вызывался конструктор копирования" << this << endl;
    }

    //перегрузка оператора присваивания 
    MyClass & operator = (const MyClass &other)
    {
        cout << "Вызывался оператор" << this << endl;

        this->size = other.size;

        if (this->data != nullptr)
        {
            delete[] this->data;
        }

        this->data = new int[other.size];

        for (int i = 0; i < other.size; i++)
        {
            this->data[i] = other.data[i];
        }
        //вернем адрес константного указателя на наш текущий объект
        return *this;
    }

    //Деструктор. 
    ~MyClass()
    {
        //уберегаем от утечки памяти для динамического массива
        delete[] data;
        cout << "Объект " << data << " Вызывался деструктор" << endl;
    }
};
    
int main()
{
    setlocale(LC_ALL, "ru");
    
    MyClass a(10);

    MyClass b(2);

    //а.оператор = (b);
    //a.operator=(b); полное написание 
    //позволяет написать так 
    a = b;
    

    return 0;
}
```

![[Pasted image 20250302202622.png]]

## Перегрузка оператора равенства. == и не равно !=. Перегрузка логических операторов сравнения

Единственным условием оператора равенства, тип должен быть bool. Так же для операторов больше или меньше типом будет bool 

В зависимости от того какой проект и какой класс. Сравнение может быть разный, если это кастомный класс, то нужно выбирать те нужные поля. 

    //тип оператора operator (какой оператор)

Можно написать длинно

```cpp
    //Перегрузка опертора сравнения
    bool operator==(const Point & other) //Передаем константу и по ссылке, это пишется всегда по обычному 
    {
        if (this->x == other.x && this->y == other.y)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
```

Или так 

```cpp
    //Перегрузка опертора сравнения
    bool operator==(const Point & other) //Передаем константу и по ссылке, это пишется всегда по обычному 
    {
        return this->x == other.x && this->y == other.y;
    }
```

```cpp
int main()
{
    setlocale(LC_ALL, "ru");
    
    Point a(5, 1);
    Point b(5, 1);

    bool result = a == b;

    return 0;
}
```

true

Оператором ! можно инвертировать. Что бы сделать обратный оператор сравнения. 

```cpp
    //Перегрузка опертора сравнения, инвертированная 
    bool operator!=(const Point &other) //Передаем константу и по ссылке, это пишется всегда по обычному
    {
        return !(this->x == other.x && this->y == other.y);
    }
```

## Свой класс String

Прекомпилированный заголовок, куда подключают другие библотеки. Что бы много раз не подключать разные библотеки. Здесь лежал все функции, классы подключенные 

```
#include "stdafx.h"
```

Каждый компонент программы отделяют в отдельный файлик. В хеадрах пишут протипы функций. Что лежит и чем можно пользоваться, а в спп файле работа

```
#pragma once 

//все что ниже нужно включать в программу один раз 
```

Empty project 

![[Pasted image 20250303162054.png]]

По документации функция main всегда должна возвращать

```
using namespace std; 
```

```cpp
class MyClass
{
public:
	MyClass();
	~MyClass();

private:

};

//конструктор 
MyClass::MyClass()
{
}

//деструктор 
MyClass::~MyClass()
{
}
```

Стандартная практика добавлять переменным членам классов префикс "m_" (member), да и само имя члена можно дать более абстрактное, например просто data

## Свой класс string 

```cpp
#include <iostream>
#include <string>
using namespace std;

class MyString
{
public:
	MyString()
	{
		str = nullptr;
	}
	MyString(const char *str)
	{
		//получаем количество символов в строке 
		int lenght = strlen(str);
		this->str = new char[lenght+1]; //что бы он понял str, который member. +1 для того то бы считал '\0'

		for (int i = 0; i < lenght; i++)
		{
			this->str[i] = str[i];
		}
		this->str[lenght] = '\0';
	}

	~MyString()
	{ 
		//должны очищать дин память, на которую указывает наш массив 
		delete[] this->str;
	}

	//конструктор копирования
	MyString(const MyString& other)
	{
		int lenght = strlen(other.str);
		this->str = new char[lenght + 1]; //что бы он понял str, который member. +1 для того то бы считал '\0'

		for (int i = 0; i < lenght; i++)
		{
			this->str[i] = other.str[i];
		}
		this->str[lenght] = '\0';
	}

	MyString& operator = (const MyString &other)
	{
		if (this->str != nullptr)
		{
			delete[] str;
		}
		int lenght = strlen(other.str);
		this->str = new char[lenght + 1]; //что бы он понял str, который member. +1 для того то бы считал '\0'

		for (int i = 0; i < lenght; i++)
		{
			this->str[i] = other.str[i];
		}
		this->str[lenght] = '\0';

		return *this;
	}

	MyString operator+ (const MyString& other)
	{
		MyString newStr;

		int thisLenght = strlen(this->str);
		int otherLenght = strlen(other.str);

		newStr.str = new char[thisLenght + otherLenght + 1];

		int i = 0;

		for (; i < thisLenght; i++)
		{
			newStr.str[i] = this->str[i];

		}

		for (int j = 0; j < otherLenght; j++, i++)
		{
			newStr.str[i] = other.str[j];
		}

		newStr.str[thisLenght + otherLenght] = '\0';

		return newStr;

	}

	void Print()
	{
		cout << str;
	}

private:
	char* str; //или m_data. читается как m_ member 
};


int main()
{
	MyString str("Hello");
	MyString str2("World");

	MyString result;
	result = str + str2;

	return 0;
}
```

## Перегрузка операторов сложения

В типе опертора указывается Point как тип возвращаемого объекта, не ссылка. Так как мы будет создавать новый объект 

Вычитания, умножение и деления будет по аналогии

```cpp
    //Перегрузка сложения 
    Point operator+ (const Point & other)
    {
        Point temp;
        temp.x = this->x + other.x;
        temp.y = this->y + other.y;
        return temp;
    }

int main()
{
    setlocale(LC_ALL, "ru");
    
    Point a(77, 1);
    Point b(5, 12);

    Point c = a + b;
    //Point c = a.operator+(b);

    return 0;
}
```

## Перегрузка оператора инкремента и декремента 

Постфиксная форма имеет самый низкий приоритет. 

Префиксная
Сначала увеличиться значение a. затем присвоится к b

```
Point b = ++a;
```

Постфиксная 
Сначала текущее значение a присвоится к b, затем увеличиться.

```
Point b =a++;
```

```cpp
    //Префиксная форма инкремента
    Point &operator++()
    {
        this->x++;
        this->y += 1;

        return *this;
    }

int main()
{
    setlocale(LC_ALL, "ru");
    
    Point a(1, 1);

    ++a;
    
    return 0;
}

```

```cpp


    //Постфиксная форма инкремента. Если есть параметр, то мы вызываем постфиксную форму. 
    Point &operator++(int value)
    {
        //имеет самый низкий приоритет 

        //создадим еще один точно такой же объект с точно такими же самыми полями на момент вызова операции постфиксного инкремента
        Point temp(*this);

        this->x++;
        this->y++;

        return temp;
    }

int main()
{
    setlocale(LC_ALL, "ru");
    
    Point a(1, 1);

    Point b = a++;

    return 0;
}

```

![[Pasted image 20250319224038.png]]

## Перегрузка оператора индексирования []

```cpp
class TestClass
{
public:
    int &operator[](int index)
    {
        return arr[index];
    }

private:
    int arr[5]{5, 44, 5, 964, 65};
};


int main()
{
    setlocale(LC_ALL, "ru");

    TestClass a;
    
    cout << a[0] << endl;

    //так как возращаем по ссылке, мы можем изменить число 
    a[0] = 100;
    cout << a[0] << endl;
    

    return 0;
}
```

## Дружественные функции и классы 

Это та функция, которая не описана внутри класса, но имеет доступ к закрытым полям класса 

```cpp
    //дружественные классы 
    friend void ChangeX(Point &value);
};

void ChangeX(Point &value)
{
    value.x = -1;
}


int main()
{
    setlocale(LC_ALL, "ru");

    Point a(5, 12);
    a.Print();
    ChangeX(a);
    a.Print();

    return 0;
}
```

![[Pasted image 20250320125633.png]]

Не работает в дружественных функциях 

```
this->
```

Одну функцию можно сделать дружественной к многим классам

## Определение методов вне класса. Вынести функцию из класса. Вынести описание метода  из класса 

Вынесенный из класса конструктор класса 

![[Pasted image 20250324132027.png]]

Вынесение из класса 

![[Pasted image 20250324132129.png]]

Create

![[Pasted image 20250324132219.png]]

```cpp
//вынесенный из класса метод 
void DetermineOutClass::PrintMessage()
{
    cout << "Hello" << endl;
}
```

С помощью такого метода создается организация. И деление на файлы. 

## Дружественный метод класса. Friend c++ Функции друзья. Переопределение методов 

Это когда один метод класса является дружественным методом класса к другому и имеет доступ к его private и protected полям 

```cpp
//Перепреоделяем, что где то есть класс Apple
class HumanForAppleClass;
class AppleClass;

class HumanForAppleClass
{
public:
    //Что бы не было ошибки в C++. Нужно вынести метод из класса 
    void TakeApple(AppleClass &apple);

    void EatApple(AppleClass &apple)
    {
    //apple. не найдет, так как не дружественный метод
    }
};

class AppleClass
{
public:
    //конструктор 
    AppleClass(int weight, string color)
    {
        //присваиваем полям класса, те данные которые передали
        this->weight = weight;
        this->color = color;
    }

    friend void HumanForAppleClass::TakeApple(AppleClass &apple);
private:
    int weight;
    string color;

};

//Основной код 
int main()
{
    setlocale(LC_ALL, "ru");

    AppleClass apple(150, "Red");

    HumanForAppleClass Human;
    Human.TakeApple(apple);

    return 0;
}

void HumanForAppleClass::TakeApple(AppleClass &apple)
{
    cout << "TakeApple " << "weight " << apple.weight << " color = " << apple.color << endl;
}

```

![[Pasted image 20250324142355.png]]

![[Pasted image 20250324142810.png]]

TakeApple weight 150 color = Red

## Переопределение методов. Определение переменной после ее включение. identifier uses undefined class after including

Переопределение работает для методов, но нельзя использовать для определения переменных заранее типом класса, который не известен 

Вы не можете определить переменные с неопределенным (заранее объявленным) типом, потому что компилятор не знает, какого размера они должны быть или как вызвать их конструктор / деструктор.

Но это можно использовать для методов 

```cpp

//Переопределение класса Pixel, что бы вывести метод TestingPixel
class Pixel;


//Класс картинки
class Image
{
public:
    //Метод, говорящий о каждом пикселе в картинке
    //Будет ругаться что используется переменная Pixels, тип Pixel которой объявлен позже
    //void GetImageInfo()
    //{
    //    for (int i = 0; i < LENGTH; i++)
    //    {
    //        cout << "#" << i << " " << Pixels[i].GetInfo() << endl;
    //    }
    //}

    //Необходимо вынести метод из класса, что бы не было ошибки 
    //Тип Pixel для методов можно определить ниже, чем вызывать 
    void TestingPixel(Pixel &pixel);

private:
    //Статическая константа количества пикселей в изображении
    static const int LENGTH = 5;

    //Картинка, состоящая из массива пикселей
    //void TakeApple(AppleClass &apple);
    //Будет ругаться что используется переменная Pixels, тип Pixel которой объявлен позже
    //Pixel Pixels[5]{
    //    Pixel(0, 4, 64),
    //    Pixel(4, 14, 10),
    //    Pixel(111, 4, 24),
    //    Pixel(244, 244, 14),
    //    Pixel(111, 179, 64)};
};

//Вынесенный из класса метод, который по ссылке принимает тип Pixel

void Image::TestingPixel(Pixel &pixel)
{
    cout << "All Fine!" << endl;
}

//Класс, описывающий пиксель изображения
class Pixel
{
public:
    //Для создания массива необходим констуктор по умолчанию, иначе массив не будет создан
    //или его придется заполнять вручную
    Pixel()
    {
        //справа на лево всем будет присвоен 0, сначала b = 0, потом g = 0..
        r = g = b = 0;
    }

    //Конструктор пикселя
    Pixel(int r, int g, int b)
    {
        this->r = r;
        this->g = g;
        this->b = b;
    }

    //Метод внутри класса Pixel который говорит о каждом поле класса
    string GetInfo()
    {
        return "Pixel: r = " + to_string(r) + " g = " + to_string(g) + " b = " + to_string(b);
    }

private:
    int r;
    int g;
    int b;
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

	//определение значений для изображения состоящий из пикселей 
    const int LENGTH = 5;
    Pixel arr[LENGTH];

    Image img;
    Pixel pixel;
    img.TestingPixel(pixel);

    return 0;
}
```


## IntelliSense . Пересобрать решение

Проверяет ошибки в коде 

Пересобрать решение

![[Pasted image 20250330204114.png]]

## Дружественные классы. ООП. friend class c++ 

```cpp
class AppleClass
{
    //Класс HumanForAppleClass дружественный класс
    friend HumanForAppleClass;
            
public:

private:

};
```

## Ключевое слово static. Статические поля класса. 

Такая переменная является общей для всех объектов одного класса. Если в каком то объекте изменить static переменную, то она изменится для всех объектов этого класса. И в следующем объекте, мы получим то значение которое указали для этой static переменной в прошлом объекте. 

Можно переменную вытащить отдельно от экземпляров класса и изменить ее, и она измениться у всех экземпляром класса 

![[Pasted image 20250401002712.png]]

```cpp
class AppleClass
{
    //Класс HumanForAppleClass дружественный класс
    friend HumanForAppleClass;

public:
    //статиченая переменная, хранит в себе количество яблок
    static int Count;

    //конструктор
    AppleClass(int weight, string color)
    {
        //присваиваем полям класса, те данные которые передали
        this->weight = weight;
        this->color = color;

        //счетчик общего числа яблок 
        Count++;

        //уникальный id для экземпляра класса 
        id = Count; 
    }

    //Метод вызова id 
    int GetId()
    {
        return id;
    }

private:
    int weight;
    int id;
    string color;
};

//инициализация статического поля вне класса
int AppleClass::Count = 0;

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    AppleClass apple(150, "Red");
    AppleClass apple2(100, "Green");
    AppleClass apple3(120, "Yellow");

	//вызов id 
    //cout << apple.GetId() << endl;
    
    cout << apple.Count << endl;
    cout << apple2.Count << endl;
    cout << apple3.Count << endl;

    cout << AppleClass::Count << endl;

    return 0;
}
```

3
3
3
3

![[Pasted image 20250401003122.png]]

![[Pasted image 20250401003208.png]]

С помощью статической переменной можно создать простейший генератор id 

## Статические методы класса. Модификатор static. 

![[Pasted image 20250401151325.png]]

Если метод не статический, то у каждого экземпляра класса он свой и к нему можно обратиться через этот экземпляр/

Статический метод знает к какому типу, классу он принадлежит, к классу AppleClass в нашем случае, но не привязан к какому конкретному объекту 

```cpp
class AppleClass
{
    //Класс HumanForAppleClass дружественный класс
    friend HumanForAppleClass;

public:

    //конструктор
    AppleClass(int weight, string color)
    {
        //присваиваем полям класса, те данные которые передали
        this->weight = weight;
        this->color = color;

        //счетчик общего числа яблок
        Count++;

        //уникальный id для экземпляра класса
        id = Count;
    }

    //Метод вызова id
    int GetId()
    {
        return id;
    }

    //статический метод вызова Count 
    static int GetCount()
    {
        //не можем вызвать так как переменная существует только в форме абстракции 
        //компилятор не может понять к какому конкретно экземпляру классы мы обращаемся, так как переменная weight 
        //создается только в самом экземпляре класса 
        //this->weight = 20;
        //weight = 20;

        return Count;
    }

    //статический метод, изменяет цвет яблока, принимает ссылку на яблоко, которому нужно изменить цвет и цвет который нужно поставить
    static void ChangeColor(AppleClass &apple, string color)
    {
        apple.color = color;
    }

private:
    int weight;
    int id;
    string color;

    //статиченая переменная, хранит в себе количество яблок
    static int Count;
};

//инициализация статического поля вне класса
int AppleClass::Count = 0;

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    AppleClass apple(150, "Red");

    apple.ChangeColor(apple, "Green");

	//Можем вызывать метод у класса и указать какому экземпляру класса применить этот метод 
    AppleClass::ChangeColor(apple, "Purple");

    return 0;
}
```

## Вложенные классы. Внутренние классы. Inner Class 

Это класс, реализация которого описана внутри другого класса. А тот который класс содержит, в который мы вкладываем этот класс называется объемлющим классом. Его создают для нужд объемлющего класса. 

```cpp

//Класс картинки
class Image
{
public:

    //Метод, говорящий о каждом пикселе в картинке 
    void GetImageInfo()
    {
        for (int i = 0; i < LENGTH; i++)
        {
            cout << "#" << i << " " << Pixels[i].GetInfo() << endl;
        }
    }


    //Внутренний класс, описывающий пиксель изображения
    class Pixel
    {
    public:
        //Конструктор пикселя
        Pixel(int r, int g, int b)
        {
            this->r = r;
            this->g = g;
            this->b = b;
        }

        //Метод внутри класса Pixel который говорит о каждом поле класса 
        string GetInfo()
        {
            return "Pixel: r = " + to_string(r) + " g = " + to_string(g) + " b = " + to_string(b);
        }

    private:
        int r;
        int g;
        int b;
    };

private:
    //Статическая константа количества пикселей в изображении
    static const int LENGTH = 5;

    //Картинка, состоящая из массива пикселей 
    Pixel Pixels[5]{
        Pixel(0, 4, 64),
        Pixel(4, 14, 10),
        Pixel(111, 4, 24),
        Pixel(244, 244, 14),
        Pixel(111, 179, 64)};
};


//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    Image img;
    img.GetImageInfo();

    Image::Pixel pixel(24, 44, 111);
    pixel.GetInfo();

    return 0;
}

```

Обращение в лежащему внутри классу 

![[Pasted image 20250401221352.png]]

Private переменные классы Pixel нам не доступны у класса Image

![[Pasted image 20250401221729.png]]

Для класса Pixel. нельзя свободно обратиться к переменной лежащей в классе Image. Нельзя обратиться к переменной, которая находится вне класса 

![[Pasted image 20250401221846.png]]

## Массив объектов класса. Динамический. Статический. Создание особенности

К массиву объектов класса, этап создания такой же как у обычного массива, за исключением что у объектов могут быть свои поля и методы класса. 

Обращаясь к элементу массива класса, можно вызвать его методы у элемента

```cpp

//Переопределение класса Pixel, что бы вывести метод TestingPixel
class Pixel;

//Класс, описывающий пиксель изображения
//Для определения типа переменной нужно что класс был выше
class Pixel
{
public:
    //Для создания массива необходим констуктор по умолчанию, иначе массив не будет создан
    //или его придется заполнять вручную
    Pixel()
    {
        //справа на лево всем будет присвоен 0, сначала b = 0, потом g = 0..
        r = g = b = 0;
    }

    //Конструктор пикселя
    Pixel(int r, int g, int b)
    {
        this->r = r;
        this->g = g;
        this->b = b;
    }

    //Метод внутри класса Pixel который говорит о каждом поле класса
    string GetInfo()
    {
        return "Pixel: r = " + to_string(r) + " g = " + to_string(g) + " b = " + to_string(b);
    }

private:
    int r;
    int g;
    int b;
};

//Класс картинки
class Image
{
public:
    //Метод, говорящий о каждом пикселе в картинке
    void GetImageInfo()
    {
        for (int i = 0; i < LENGTH; i++)
        {
            cout << "#" << i << " " << Pixels[i].GetInfo() << endl;
        }
    }

    //Необходимо вынести метод из класса, что бы не было ошибки
    void TestingPixel(Pixel &pixel);

private:
    //Статическая константа количества пикселей в изображении
    static const int LENGTH = 5;

    //Картинка, состоящая из массива пикселей
    //void TakeApple(AppleClass &apple);
    Pixel Pixels[5]{
        Pixel(0, 4, 64),
        Pixel(4, 14, 10),
        Pixel(111, 4, 24),
        Pixel(244, 244, 14),
        Pixel(111, 179, 64)};
};

//Вынесенный из класса метод, который принимает по ссылке пиксель
void Image::TestingPixel(Pixel &pixel)
{
    cout << "All Fine!" << endl;
}
```

Статический массив 

```cpp
//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    const int LENGTH = 5;
    Pixel arr[LENGTH];

    //добавить элемент обращаясь к индексу 
    arr[0] = Pixel(11, 159, 222);
    cout << arr[0].GetInfo() << endl;

    //добавить элемент
    //Либо поэлементно указать 
    Pixel arr[LENGTH]
    {
        Pixel(11, 55, 66);
        Pixel(11, 55, 66);
        Pixel(11, 55, 66);
        Pixel(11, 55, 66);
        Pixel(11, 55, 66);       
    }

    //обращение к элементу по индексу 
    cout << arr[0].GetInfo() << endl;

    return 0;
}
```

Динамический массив 

```cpp
//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    //Динамический массив
    int LENGTH = 5;

    //указатель arr на тип pixel
    Pixel *arr = new Pixel[LENGTH];

    arr[0] = Pixel(11, 115, 55);

    cout << arr[0].GetInfo() <<endl;

    delete[] arr;

    return 0;
}
```

## Что такое агрегация и композиция 


Включение одного класса в другого.
Явление когда какой то класс используется в другом

Агрегация позволяет использоваться тот класс, который мы включаем еще в других местах, в других классах

Композиция, класс который включается в другой, без этого класса просто не может существовать 

```cpp
//Пример агрегации, класс кепки, жестко к человеку не привязан
//Класс, который мы используем с другими классами, жестко не привязан к классу
class Cap
{
public:
    string GetColor()
    {
        return color;
    }

private:
    string color = "red";
};

//Пример агрегации, использование другого класса в классе, не привязанном к этому классу 
class Model
{
public:
    void InspectModel()
    {
        cout << "Кепка " << cap.GetColor() << " цвета" << endl;
    }

private:
    Cap cap;
};

//Пример композиции, жесткой привязки одного объекта к другому
class Human
{
public:
    void Think()
    {
        //делегирование
        brain.Think();
    }

    //агрегация
    void InspectTheCap()
    {
        cout << "Моя кепка " << cap.GetColor() << " цвета." << endl;
    }

private:
    //Класс Brain без класса Human никак сущестовать не может
    //Если уничтожается класс Human, то уничтожается и класс Brain
    //Так как класс описан в private секции, то мы нигде его больше использовать не можем
    class Brain
    {
    public:
        void Think()
        {
            cout << "Я думаю!" << endl;
        }
    };

    Brain brain;

    //Агрегация 
    Cap cap;
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    Human human;
    human.Think();
    human.InspectTheCap();

    Model m;
    m.InspectModel();
    return 0;
}
```

## Наследование в ООП. Что такое наследование. Для чего нужно наследование

Одинаковые поля и могут быть одинаковые методы. Невозможность применения полиморфизма, невозможность хранения коллекции из людей, стдуентов и профессор, так как это все разные люди

```cpp
class Human
{
public:
    string name;
};

class Student
{
public:
    string name;
    string group;
};

class Professor
{
public:
    string name;
    string subject;
};
```

Мы можем унаследовать класс студента и класс профессора от человека, то есть они получат класс имени от человека

```cpp
class Human
{
public:
    string name;
};

//синтаксис наследования
//"тип и название класса" ": двоеточие" "модификатор наследования" "класс от которого наследуемся"
class Student : public Human
{
public:
    string group;
};

class Professor : public Human
{
public:
    string subject;
};

```

![[Pasted image 20250407233615.png]]

Студент включает в себя весь функционал человека

![[Pasted image 20250407233904.png]]

Реализация наследование класса от наследованного класса

```cpp
class Human
{
public:
    string name;
};

//синтаксис наследования
//"тип и название класса" ": двоеточие" "модификатор наследования" "класс от которого наследуемся"
class Student : public Human
{
public:
    string group;

    void Learn()
    {
        cout << "Я учусь!" << endl;
    }
};

class ExtramuralStudent : public Student
{
public:
    void Learn()
    {
        cout << "Я бываю в университете реже обычного студента! " << endl;
    }
};

class Professor : public Human
{
public:
    string subject;
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    Student st;
    
    Professor pr;

    ExtramuralStudent extraSt;

    extraSt.Learn();

    return 0;
}
```

При включение поля name в private. Это поля будет скрыто, но все так же включено 

```cpp
class Human
{
private:
    string name;
};
```

![[Pasted image 20250407234442.png]]

```cpp
//Все классы, унаследованные от класса human получат сеттеры и геттеры этого класса 
class Human
{
public:
    string GetName()
    {
        return name;
    }

    void SetName(string name)
    {
        this->name = name;
    }

private:
    string name = "Иван Иванович";
};

//синтаксис наследования
//"тип и название класса" ": двоеточие" "модификатор наследования" "класс от которого наследуемся"
class Student : public Human
{
public:
    string group;

    void Learn()
    {
        cout << "Я учусь!" << endl;
    }
};

class ExtramuralStudent : public Student
{
public:
    void Learn()
    {
        cout << "Я бываю в университете реже обычного студента! " << endl;
    }
};

class Professor : public Human
{
public:
    string subject;
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    Student st;
    st.Learn();
    st.SetName("Аристарх");
    cout << st.GetName() << endl;

    Professor pr;

    ExtramuralStudent extraSt;
    extraSt.Learn();
    extraSt.SetName("Евлампий");
    extraSt.GetName();

    return 0;
}
```

## Модификаторы доступа при наследовании. Private, public, Protected 

```cpp
class A
{
public:
    string msgOne = "Сообщение один";

private:
    string msgTwo = "Сообщение два";

protected:
    string msgThree = "Сообщение три";

};

```

```cpp
//наиболее распространный вариант 
class B : public A
{
public:
    void PrintMsg()
    {
        cout << msgOne << endl;
    }
};


//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    B b;

    b.PrintMsg();
    b.msgOne;

    return 0;
}
```

Не возможно добраться до поля msgTwo, так как он лежит в private поле 

![[Pasted image 20250408030514.png]]

К полю protected мы можем обратиться внутри класса, но не можем вызвать его в основном коде 

```cpp
class A
{
public:
    string msgOne = "Сообщение один";

private:
    string msgTwo = "Сообщение два";

protected:
    string msgThree = "Сообщение три";

};

class B : public A
{
public:
    void PrintMsg()
    {
        cout << msgThree << endl;
    }
};


//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    B b;

    b.PrintMsg();

    return 0;
}
```

![[Pasted image 20250408030728.png]]

Если мы изменяем модификаторы доступа наследования 

Public - доступно везде и всем
Private - закрыто ото всех, кроме конкретного класса, в котором было создано. Не в классе наследнике внутри, не в уровне объектах, через точку обратиться не можем
Protected - через точку обратиться не можем, но в наследниках обратиться можем 

![[Pasted image 20250408031105.png]]



```cpp
//модификаторы доступа у класса А, остаются не изменными по своему значению 
class B : public A

//модификаторы доступа у класса А, все становятся private и получить доступ к данным больше нельзя, но можно увидеть их
class B : private A

//модификаторы доступа у класса А, повлияет только на public поле, оно станет protected полем и будет вести себя как он 
class B : protected A
```

## Порядок вызова конструкторов при наследовании. Как вызываются конструкторы 

```cpp
class A
{
public:
    A()
    {
        cout << "Вызвался конструктор класса А" << endl;
    }
};


class B : public A
{
public:
    B()
    {
        cout << "Вызвался конструктор класса B" << endl;
    }
};

class C : public B
{
public:
    C()
    {
        cout << "Вызвался конструктор класса C" << endl;
    }
};


//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    C c;

    return 0;
}
```

Вывод:

Вызвался конструктор класса А
Вызвался конструктор класса B
Вызвался конструктор класса C

Это происходит потому что конструирование объектов происходит вот по такому методу, потому класс С должен содержать Б и А. Не может существовать, пока не создан класс Б, а он пока не существует класс А. 

![[Pasted image 20250408032536.png]]

## Порядок вызова деструктора при наследовании. Деструкторы. 
 

```cpp
class A
{
public:
    A()
    {
        cout << "Вызвался конструктор класса А" << endl;
    }

    ~A()
    {
        cout << "Вызвался деструктор класс А" << endl;
    }
};


class B : public A
{
public:
    B()
    {
        cout << "Вызвался конструктор класса B" << endl;
    }

    ~B()
    {
        cout << "Вызвался деструктор класс B" << endl;
    }
};

class C : public B
{
public:
    C()
    {
        cout << "Вызвался конструктор класса C" << endl;
    }

    ~C()
    {
        cout << "Вызвался деструктор класс C" << endl;
    }
};


//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    C value;

    return 0;
}
```

Порядок вызова деструктора идет в обратном порядке, как матрешка

Вызвался конструктор класса А
Вызвался конструктор класса B
Вызвался конструктор класса C

Вызвался деструктор класс C
Вызвался деструктор класс B
Вызвался деструктор класс А

## Вызов конструктора базового класса из конструктора класса-наследника. Наследование 

```cpp
class A
{
public:
    A()
    {
        msg = "Пустое сообщение";
    }

    A(string msg)
    {
        this->msg = msg;
    }


    void PrintMsg()
    {
        cout << msg << endl;
    }

private:
    string msg;
};


class B : public A
{
public:
    //если нужно вызвать конкретный конструктор из нескольких конструкторов родительского конструктора
    //конструктор всегда хочет вызвать конструктор по умолчанию 
    //комполятор дописывает эту вещь самостоятельно
    //Если конструктора по умолчанию нет, то будет ошибка. Мы должны в этом случае указать конкретный констуктор
    //здесь мы обращаемся ко второму конструктору 
    B(): A("Наше новое сообщение")
    {

    }

};


//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    B value;
    value.PrintMsg();

    return 0;
}
```

## Виртуальные методы класса C++. Ключевое слово virtual. Ключевое слово override

Проявление полиморфизма - это когда у объектов есть метод, но в зависимости от объекта проявляется он по разному 

Пример: есть пистолет и у него метод стрелять, стрелять он будет одиночными выстрелами. И есть пистолет-пулемет, у него тоже есть метод стрелять, но стрелять он будет автоматически или очередью.

То есть мы можем от класса пистолет, сделать наследником пистолет-пулемет и переопределить метод выстрелить. 

Объект класса определяет его проявление 


![[Pasted image 20250408163209.png]]

```cpp

class Gun
{
public:
    //Виртуальный метод, теперь его можно переопределить в классе наследнике. 
    //Ключевое слово virtual, так же будет работать и без него, но возможно ошибки
    //если совершить ошибку, то может создаться новый метод, а не перезапись его 
    //но если работаем с override, то он не даст не написать его
    virtual void Shoot()
    {
        cout << "Bang!" << endl;
    }
};

class SubmachineGun : public Gun
{
public:
    //Что бы метод Shoot точно переопредял нужный нам метод, он должен идеально совпадать 
    //если что то пойдет не так, и допустим укажете объекты для ввода, где метод их не принимает
    //что бы не создался новый метод используют override 
    //override - подсказка, комплитор говорит что метод уже не перепределяет метод другого класса 
    //так же override заставит добавить ключевое слово virtual для метода, который будет переопределен
    //поэтому override необходимо использовать всегда
    void Shoot() override
    {
        cout << "Bang! Bang! Bang!" << endl;
    }
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    Gun gun;
    SubmachineGun machinegun;

    //Пример полиморфизма, в зависимости от класса метод введет себя по разному 

    //Если вызвать так будет Bang!
    //Gun *weapon = &gun;

    //Если вызвать так будет Bang! Bang! Bang!
    Gun *weapon = &machinegun;

    weapon->Shoot();

    return 0;
}
```

То почему это и зачем должно работать 

При передаче новой пушки, игроку, которая является чайлдом от gun, мы можем давать ему различные оружия, просто создавая новые чайлды. Передавая родитель как указатель и передавая детей по ссылке. И с помощью override мы можем перезаписывать один и тот же метод стрелять для разных оружий.

```cpp
//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    Gun gun;
    SubmachineGun machinegun;

    Player player;

    //Везде где указатель *gun, мы должны передавать ссылку &gun
    player.Shoot(&machinegun);

    return 0;
}
```

## Абстрактный класс. Чисто виртуальная функция. virtual override. Полиморфизм 

Чисто виртуальная функция - это пустая функция, реализация которой не описана. Такой класс является абстрактным. А экземпляры абстрактного класса, компилятор не позволяет создавать. 

Если в таком классе есть чисто виртуальная функция, без реализации и мы создадим такой объект и попытаемся обратиться к такому методу, то компилятор просто не будет знать что с этим делать. Поэтому создание экземпляров абстрактного класса запрещено 

```cpp
//Абстрактный класс оружия 
class Weapon
{
    //так мы сообщаем что эта функция чисто виртуальная 
    virtual void Shoot() = 0;
};
```

![[Pasted image 20250409223048.png]]

```cpp
//Абстрактный класс оружия 
class Weapon
{
public:
    //так мы сообщаем что эта функция чисто виртуальная 
    virtual void Shoot() = 0;

    //В классах родителях, так же могут быть обычные, не абстрактные методы
    void Foo()
    {
        cout << "Foo()" << endl;
    }
};

class Gun : public Weapon
{
public:
    void Shoot() override
    {
        cout << "Bang!" << endl;
    }
};

//Можно оставить его наследником Gun и он будет работать
class SubmachineGun : public Gun
{
public:
    void Shoot() override
    {
        cout << "Bang! Bang! Bang!" << endl;
    }
};

class Bazooka : public Weapon 
{
public:
    void Shoot() override
    {
        cout << "BOOOM!" << endl;
    }
};

class Knife : public Weapon
{
public:
    void Shoot() override
    {
        cout << "VJUH!" << endl;
    }
};

class Player
{
public:
    void Shoot(Weapon *weapon)
    {
        weapon->Shoot();
    }
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    //оружие
    Gun gun;
    SubmachineGun machinegun;
    Bazooka bazooka;
    Knife knife;

    //другие обычные методы лежащие в weapon
    knife.Foo();

    //игрок
    Player player;

    //применение оружия по ссылке 
    player.Shoot(&knife);

    return 0;
}
```

В weapon лежит указатель на класс knife

![[Pasted image 20250409224501.png]]

Теперь мы можем создавать различные методы, но все должны исходить из абстрактного класса

## Виртуальный деструктор  

Для хранения ссылок на классов наследников необходимо использовать виртуальные деструктора, что бы при логике работала переопределение деструктора 

```cpp
class A
{
public:
    A()
    {
        cout << "Выделена динамическая память, объект класса А" << endl;
    }
    virtual ~A()
    {
        cout << "Освобожена динамическая память, объект класса А" << endl;
    }
};

class B : public A
{
public:
    B()
    {
        cout << "Выделена динамическая память, объект класса B" << endl;
    }
    ~B() override
    {
        cout << "Освобожена динамическая память, объект класса B" << endl;
    }
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    A *bptr = new B;
    delete bptr;


    return 0;
}
```

## Чисто виртуальный деструктор 

Он нужен для родительский классов 

```cpp
class A
{
public:
    A()
    {
    }
    virtual ~A() = 0;
};

//необходимо вынести и переопредлить 
A::~A() {};

class B : public A
{
public:
    B()
    {
    }
    ~B() override
    {
    }
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");
    
    //Переменная bptr имеет тип указатель на А
    //в bptr записывается адрес нового объекта B, созданного в куче (heap) через new
    //Так как B наследуется A
    //int* a, b; // b — просто int, НЕ указатель!
    A* bptr = new B;

    //Освобождение памяти выделенная под объект B
    //Для A необходим виртуальный деструктор 
    delete bptr;
    return 0;
}
```

## Делегирующие конструкторы 

Для того что бы было проще писать код и легче вносить правки 

Вместо этого 

```cpp
    HumanDelegateConstruct(string Name)
    {
        this->Name = Name;
        this->Age = 0;
        this->Weight = 0;
    }

    HumanDelegateConstruct(string Name, int Age)
    {
        this->Name = Name;
        this->Age = Age;
        this->Weight = 0;
    }

    HumanDelegateConstruct(string Name, int Age, int Weight)
    {
        this->Name = Name;
        this->Age = Age;
        this->Weight = Weight;
    }
```

Можем использовать это 

```cpp
//класс использующий делегирующие конструкторы
class HumanDelegateConstruct
{
public:
    HumanDelegateConstruct(string Name)
    {
        this->Name = Name;

        this->Age = 0;
        this->Weight = 0;
    }

    //новые инициализаторы, когда их много легче их понимать когда они идут в столбик 
    //во время вызова этого констурктора, так же вызовется и 1 конструктор
    //сначала по логике идет конструктор 1, потом 2
    HumanDelegateConstruct(string Name, int Age)
        : HumanDelegateConstruct(Name)
    {
        this->Age = Age;
    }

    //здесь сначала иницилизируется конструктор 2, потом он делегирует 1, затем возвращается 2, 
    //и затем уже в 3
    HumanDelegateConstruct(string Name, int Age, int Weight)
        : HumanDelegateConstruct(Name, Age)
    {
        this->Weight = Weight;
    }

    string Name;
    int Age;
    int Weight;
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    HumanDelegateConstruct h("Аристарх", 30, 100);

    return 0;
}
```

## Вызов виртуального метода базового класса 

Если мы хотим вызвать переопредленный метод базового класса, в классе наследнике, более того в переопредлямом методе. Надо дать компилятятору понять какой именно метод вызываем 

```cpp
class Msg
{
public:
    //принимает и хранит строчку msg
    Msg(string msg)
    {
        this->msg = msg;
    }

    //Виртуальный метод, который возвращает строчку msg
    virtual string GetMsg()
    {
        return msg;
    }

private:
    string msg;
};

//Будет распечатывать сообщения, которые ему приходят параметром указатель на msg
//Переменная msg с типом указатель на Msg
//Указатель на класс Msg, говорит о том что можно мы можем принимать не только класс Msg
//Но и наследников класса Msg
class Printer
{
public:
    void Print(Msg* msg)
    {
        cout << msg->GetMsg() << endl;
    }
};

//Наследник класса Msg
class BraketMsg : public Msg
{
public:
    //Будет инициализировать конструктор Msg, который принимает параметр msg
    BraketMsg(string msg)
        : Msg(msg)
    {
    }

    //так же он будет переопределять метод GetMsg
    string GetMsg() override
    {
        //рекурсивный вызов метода самого себя
        //return "[" + GetMsg() + "]";

        //вызов метод именно базового класса 
        return "[" + ::Msg ::GetMsg() + "]";
    }
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    BraketMsg m("Привет!");

    Printer p;
    p.Print(&m);

    return 0;
}
```

## Множественное наследование 

Класс можно унаследовать от нескольких классов 

```cpp
class Car
{
public:
    string str = "Поле класса машина";
    void Drive()
    {
        cout << "Я еду!" << endl;
    }
};

class Airplain
{
public:
    string str2 = "Поле класса самолет";
    void Fly()
    {
        cout << "Я лечу!" << endl;
    }
};

//Наследник Car и Airplain
class FlyingCar :  public Car, public Airplain
{
    
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    Car c;
    c.Drive();

    Airplain a;
    a.Fly();

    FlyingCar fc;
    fc.Drive();
    fc.Fly();
    fc.str = "Я новое поле!";

    //Переменная ptrC типа указатель на тип Car, которой присваевается ссылка на объект fc
    //который принадлежит типу FlyingCar, который наследник двух классов Car, Airplane
    //указатель хранит адрес, а не значение, поэтому присвоить переменную нельзя 
    Car* ptrC = &fc;

    Airplain* prtA = &fc;

    return 0;
}
```

![[Pasted image 20250418065758.png]]

![[Pasted image 20250418065943.png]]

## Порядок вызова конструкторов при множественном наследовании 

ctor + tab Visual Studio напишет конструктор за вас. Сокращенно конструктор 

```cpp
class Airplain
{
public:
    Airplain()
    {
        cout << "Вызван конструктор Airplain" << endl;
    }

    string str2 = "Поле класса самолет";
    void Fly()
    {
        cout << "Я лечу!" << endl;
    }
};

//Наследник Car и Airplain
class FlyingCar : public Airplain, public Car
{
public:
    FlyingCar()
    {
        cout << "Вызван конструктор FlyingCar" << endl;
    }
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    FlyingCar fc;

    return 0;
}
```

Порядок наследования зависит от того что первым указано 

```cpp
//Наследник Car и Airplain
class FlyingCar : public Airplain, public Car
```

Вызван конструктор Airplain
Вызван конструктор Car
Вызван конструктор FlyingCar

## Порядок вызова деструкторов при множественном наследовании 

```cpp
//Множественное наследование
class Car
{
public:
    Car()
    {
        cout << "Вызван конструктор Car" << endl;
    }
    ~Car()
    {
        cout << "Вызван деструктор Car" << endl;
    }

    string str = "Поле класса машина";
    void Drive()
    {
        cout << "Я еду!" << endl;
    }
};

class Airplain
{
public:
    Airplain()
    {
        cout << "Вызван конструктор Airplain" << endl;
    }
    ~Airplain()
    {
        cout << "Вызван деструктор Airplain" << endl;
    }

    string str2 = "Поле класса самолет";
    void Fly()
    {
        cout << "Я лечу!" << endl;
    }
};

//Наследник Car и Airplain
class FlyingCar : public Airplain, public Car
{
public:
    FlyingCar()
    {
        cout << "Вызван конструктор FlyingCar" << endl;
    }
    ~FlyingCar()
    {
        cout << "Вызван деструктор FlyingCar" << endl;
    }
};
///////////////

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    FlyingCar fc;

    cout << endl
         << endl;

    return 0;
}

```

Вызван конструктор Airplain
Вызван конструктор Car
Вызван конструктор FlyingCar


Вызван деструктор FlyingCar
Вызван деструктор Car
Вызван деструктор Airplain

## Ошибки в программировании 

### Ошибки на этапе компиляции - 

Когда среда разработки не понимает что ей написали, не может скомпилировать, перевести в двоичный язык. Ошибки связанные с синтаксисом 

ошибки связанные со скобочками 
ошибки с неправильным написание слов 

![[Pasted image 20250419002020.png]]

На месте красной точки есть ошибка 

![[Pasted image 20250419002221.png]]

### Ошибка во время выполнения или ошибка времени выполнения 

Программист не продумал все действия

При вводе 0 программа падает

```cpp
    int a = 4;
    int b;
    cin >> b;

    cout << a / b << endl;
```

### Логические ошибки

Ошибся когда программист сам ошибся, когда строил логику программы 


Если программист написал -, вместо +. который он хотел 

`    cout << a - b << endl;`


`    cout << a + b << endl;`

Решение отладчик

## Множественное наследование, одинаковые методы

![[Pasted image 20250419003646.png]]

//Метод Use, который отличается только реализацией в двух классах

![[Pasted image 20250419003620.png]]

```cpp
//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    FlyingCar fc;
    
    //приведение к типу Car
    ((Car)fc).Use();

    cout << endl;

    //приведение к типу Airplane
    ((Airplain)fc).Use();

    return 0;
}
```

Я еду!

Я лечу!

## Что такое интерфейс в ООП 

Интерфейс - публичные методы с помощью которых можно взаимодействовать с сущностью. 

Научившись ездить один раз на велосипеде, человек может ездить на любых других велосипедах. Он научился интерфейсу велосипеда

А это значит что любой объект, использующий интерфейс велосипеда, покрутить педали, покрутить руль. Любой человек сможет использовать этот объект.

Интерфейс - это абстрактный класс, в котором все методы чисто виртуальные. В нем не может быть никакой реализации, потому что мы не знаем что это такое будет. 

При множественном наследовании интерфейсов, реализация методов ложиться на переопределение методов

```cpp
//Интерфейс
class IBicycle
{
public:
    void virtual TwistTheWheel() = 0;
    void virtual Ride() = 0;
};

//Релизовываем интерфейс в наследнике
class SimpleBicyle : public IBicycle
{
public:
    void TwistTheWheel() override
    {
        cout << "метод TwistTheWheel() SimpleBicyle" << endl;
    }
    void Ride() override
    {
        cout << "метод Ride() SimpleBicyle" << endl;
    }
};

//таким образом мы можем реализовать много разных велосипедов и каждым из них человек сможет пользоваться
class SportBicylce : public IBicycle
{
    void TwistTheWheel() override
    {
        cout << "метод TwistTheWheel() SportBicylce" << endl;
    }
    void Ride() override
    {
        cout << "метод Ride() SportBicylce" << endl;
    }
};

class HumanForBicycle
{
public:
    void RideOn(IBicycle& bicycle)
    {
        cout << "Крутим руль" << endl;
        bicycle.TwistTheWheel();
        cout << endl
             << "Поехали" << endl;
        bicycle.Ride();
    }
};
///////////////////////////////////////

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    SimpleBicyle sb;
    SportBicylce sportB;

    HumanForBicycle h;
    h.RideOn(sportB);

    return 0;
}
```

## Виртуальное наследование. Ромбовидное наследование

```cpp
//Виртуальное наследование. Ромбовидное наследование
//Родительский класс
class Component
{
public:
    Component(string companyName)
    {
        cout << "Конструктор Component" << endl;
        this->CompanyName = companyName;
    }
    string CompanyName;
};

//Класс чайлд от класса компонент
class GPU : public Component
{
public:
    //вызывается реализация конструктора из класса Component, в нашем случае это базовый конструктор
    //В два значения передается название компании
    GPU(string companyName)
        : Component(companyName)
    {
        cout << "Конструктор GPU " << endl;
    }
};

class Memory : public Component
{
public:
    //вызываются два конструктора
    Memory(string companyName)
        : Component(companyName)
    {
        cout << "Конструктор Memory " << endl; 
    }
};

class GraphicCard : public GPU, public Memory
{
public:
    GraphicCard(string GPUCompanyName, string MemoryCompanyName)
        : GPU(GPUCompanyName), Memory(MemoryCompanyName)
    {
        cout << "Конструктор GraphicCard" << endl;
    }
};


//Основной код
int main()
{
    setlocale(LC_ALL, "ru");
    
    GraphicCard gc("AMD", "Samsung");

    return 0;
}
```

Конструктор Component
Конструктор GPU
Конструктор Component
Конструктор Memory
Конструктор GraphicCard

![[Pasted image 20250420045755.png]]

Нам нужно что бы класс Character был в этой структуре только один раз, иначе поле HP будет дублироваться два раза. Виртуальное наследование

```cpp
class Character
{
public:
    Character()
    {
        cout << "Конструктор Character " << endl;
    }
    int HP = 100;
};

//виртуальное наследование
class Orc : public virtual Character
{
public:
    Orc()
    {
        cout << "Конструктор Orc " << endl;
    }
};

//виртуальное наследование
class Warrior : public virtual Character
{
public:
    Warrior()
    {
        cout << "Конструктор Warrior " << endl;
    }
};

class OrcWarrior : public Orc, public Warrior
{
public:
    OrcWarrior()
    {
        cout << "Конструктор OrcWarrior " << endl;
    }
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    OrcWarrior orc;

    return 0;
}
```

Конструктор Character
Конструктор Orc
Конструктор Warrior
Конструктор OrcWarrior

Ромбовидное наследование, получается вот такое 

![[Pasted image 20250420050920.png]]

## Работа с файлами. Запись в файл. C++ ofstream

Отвечает за это библиотека fstream 

`#include <fstream>`

```cpp
//Запись в файл 
#include <fstream>

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    string path = "myFile.txt";
    
    //ввод пути к файлу
    //cin >> path;

    //сохранение 
    //появится в папке с проектом
    ofstream fout;

    //трет прошлые данные, если не указать
    //ofstream::app добавить данные в конец
    fout.open(path, ofstream::app);

    //удалось ли открыть файл
    if (!fout.is_open())
    {
        cout << "Ошибка открытия файла!" << endl;
    }
    else
    {
        for (int i = 0; i < 5; i++)
        {
            cout << "Введите число!" << endl;
            int a;
            cin >> a;
            //сохранение строчки это наши данные
            fout << a;
            fout << "\n";
        }
    }
    
    fout.close();

    return 0;
}
```

![[Pasted image 20250420063229.png]]

## Чтение из файла. Ifstream 

```cpp
//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    string path = "myFile.txt";

    //открытие файла 
    ifstream fin;
    fin.open(path);

    if (!fin.is_open())
    {
        cout << "Ошибка открытия файла!" << endl;
    }
    else
    {
        cout << "Файл открыт!" << endl;
        string str;
        char ch;
        //char str[50];

        //метод get берет по 1 символу 
        //while (fin.get(ch))
        
        //всегда возрващает true пока не будет конец файла
        while (!fin.eof())
        {
            str = "";
            //берем строчку, перестает считывать данные когда переходит на новую строчку
            getline(fin, str);

            //берет количество символов, сколько надо считать менее удобно
            //fin.getline(str, 50); 

            cout << str << endl;
        }
    }
    //освобождение ресурсов
    fin.close();

    return 0;
}
```

Файл открыт!
первая строка
вторая строка

## Запись объекта класса в файл. Чтение объектов из файла

```cpp
class PointFile
{
public:
    PointFile()
    {
        x = y = z = 0;
    }
    PointFile(int x, int y, int z)
    {
        this->x = x;
        this->y = y;
        this->z = z;
    }

    void Print()
    {
        cout << "X: " << x << "   "
             << "Y: " << y << "   "
             << "Z: " << z << endl;
    }

    int x;
    int y;
    int z;
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    string path = "myFile.txt";

    PointFile point(1455, 15151, 52);

    point.Print();

    /*
    //сохранение
    ofstream fout;

    //трет прошлые данные, если не указать
    //ofstream::app добавить данные в конец
    fout.open(path, ofstream::app);

    //удалось ли открыть файл
    if (!fout.is_open())
    {
        cout << "Ошибка открытия файла!" << endl;
    }
    else
    {
        cout << "Файл открыт!" << endl;

        //запись файла, фаил и размер объекта
        fout.write((char*)&point, sizeof(Point));
    }

    fout.close();
    */

    //чтение 
    ifstream fin;
    fin.open(path);

    if (!fin.is_open())
    {
        cout << "Ошибка открытия файла!" << endl;
    }
    else
    {
        cout << "Файл открыт!" << endl;

        //когда объект считает данные, он заполнит эту переменную новыми данными
        Point pnt;
        
        while (fin.read((char*)&pnt, sizeof(Point)))
        {
            pnt.Print();
        }
    }

    fin.close();

    return 0;
}
```

Мы записываем данные 3 разных точек в файл, так как это записывает в двоичной системе выглядеть оно будет так

![[Pasted image 20250421055252.png]]

Затем когда мы берем этот файл и уже читаем его в программе, там оно конвертируется и получаем данные наших точек

![[Pasted image 20250421055239.png]]

## Чтение и запись в файл. Fstream C++

```cpp
//библиотека для записи русских символов в файл
#include <Windows.h>

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    string path = "myFile.txt";

    fstream fs;

    //2 параметров передается режим открытия файла
    //вы имеем возможность открытия файла для чтение
    //мы можем совмещать режимы работы файла с помощью ИЛИ
    //битовое ИЛИ |, логическое ||
    //out - так же мы можем работать на запись, не только на чтение 
    //app -добавление в конец новых данных
    fs.open(path, fstream::in | fstream::out | fstream::app);

    //удалось ли открыть файл
    if (!fs.is_open())
    {
        cout << "Ошибка открытия файла!" << endl;
    }
    else
    {
        string msg;
        int value;
        cout << "Файл открыт!" << endl;
        cout << "Введите 1 для записи сообщения в файл:" << endl;
        cout << "Введите 2 для считывания всех сообщений из файла:" << endl;
        cin >> value;

        if (value == 1)
        {
            cout << "Введите сообщение" << endl;

            //кодировка для русских символов
            SetConsoleCP(1251);

            cin >> msg;
            //помещаем данные в файл
            fs << msg << "\n";

            //возвращаем кодировку назад
            SetConsoleCP(866);
        }

        if (value == 2)
        {
            cout << "Чтение данных из файла" << endl;
            //пока не конец файла
            while (!fs.eof())
            {
                //затирать предыдущее сообщение, что бы сообщение не дублировалось
                msg = "";

                fs >> msg;
                cout << msg << endl;
            }
        }
    }

    //освобождение ресурсов
    fs.close();

    return 0;
}
```

## Потоковый ввод вывод в файл. Перегрузка операторов << >>


```cpp
        //записать в файл
        //из переменной в файл
        fs << a;

        //из файла в переменную
        //fs >> a;

    //записать в cout переменную point 
    cout << point;

    //int a = 5;
    //cout << a;

```

```cpp
//класс для записи в фаил
class PointFile
{
public:
    PointFile()
    {
        x = y = z = 0;
    }
    PointFile(int x, int y, int z)
    {
        this->x = x;
        this->y = y;
        this->z = z;
    }

    /*   void Print()
    {
        cout << "X: " << x << "   "
             << "Y: " << y << "   "
             << "Z: " << z << endl;
    }*/

private:
    int x;
    int y;
    int z;

    //дружественные класс для двух методов вывода и записи
    //что бы они имели доступ к полям в private 
    friend ostream& operator<<(ostream& os, const PointFile& point);
    friend istream& operator>>(istream& is, PointFile& point);
};


//fstream, cout, ostream они все связаны цепочкой наследования,
//так что он все их поймет
ostream& operator<<(ostream& os, const PointFile& point)
{
    //при private
    //доступ к полям нужно делать через Get / Set
    //либо сделать дружественными методами 
    os << point.x << " " << point.y << " " << point.z;

    return os;
}

//перегрузка >>
//считываение данных
istream& operator>>(istream& is, PointFile& point)
{
    is >> point.x >> point.y >> point.z;
    return is;
}

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    string path = "myFile.txt";

    PointFile point(355, 351, 52);

    //записать в cout переменную point
    //cout << point;

    //int a = 5;
    //cout << a;

    fstream fs;

    fs.open(path, fstream::in | fstream::out | fstream::app);

    //удалось ли открыть файл
    if (!fs.is_open())
    {
        cout << "Ошибка открытия файла!" << endl;
    }
    else
    {
        cout << "Файл открыт!" << endl;

        //записать в файл
        //из переменной в файл
        //fs << point << "\n";

        //из файла в переменную
        //fs >> a;

        //считывание всех данных с файла 
        //while (!fs.eof()) не обязательная проверка на конец файла, она уже есть 
        while (true)
        {
            PointFile p;
            fs >> p;

            //проверка на конец файла 
            if (fs.eof())
            {
                break;
            }

            cout << p << endl;
        }
    }
    fs.close();

    return 0;
}
```


## Порядок записи и составления .h и .cpp файлов и их подключение 

в .h файлы записываются библиотеки, название класса, название конструкторолв, названия методов, переменные в private поле 
в .cpp файл записываются реализация методов класса и реализация конструкторов 


## Правила написания переменных 

|Что|Как принято писать|
|---|---|
|Классы|`PascalCase`: `OfstreamWritingInFile`|
|Методы|`PascalCase`: `SaveFile()`, `WriteData()`|
|Переменные|`camelCase`: `path`, `fileStream`, `isOpen`|
|Константы|`SCREAMING_SNAKE_CASE`: `MAX_SIZE`, `DEFAULT_PATH`|

## Try catch. Обработка исключений в C++ 


```cpp
int main()
{
    setlocale(LC_ALL, "ru");

    string path = "MyFile.tx";

    ifstream fin;
    ///специфика запуска ifstream 
    fin.exceptions(ifstream::badbit | ifstream::failbit);

    try
    {
        //пробуем что то выполнить, открыть
        cout << "Попытка открыть файл!" << endl;
        //если что то пойдет не так, дальнейшая строчка не выведется 
        //но выведется catch 
        fin.open(path);
        cout << "Файл успешно открыт!" << endl;
    }
    //стандартный класс
    //константная ссылка на объект exception
    //catch (const std::exception& ex)
    //ifstream::failure& - класс exception именно для ifstream
    catch (const ifstream::failure& ex)
    {
        //если что то пошло не так, будем ловить тут
        cout << ex.what() << endl;
        //вывод кода ошибки 
        cout << ex.code() << endl;
        cout << "Ошибка открытия файла" << endl;
    }

    return 0;
}
```

Попытка открыть файл!
ios_base::failbit set: iostream stream error
iostream:1
Ошибка открытия файла

## Генерация исключений, throw C++

![[Pasted image 20250502213628.png]]

```cpp
void FooThrow(int value)
{
    //можем передать число, строку, класс
    if (value < 0)
    {
        //если бросить throw, и не поймать его будет ошибка
        //throw value;
        //throw "Число меньше 0";
        //более универсальное решение через класс exception
        throw exception("Число меньше 0");
    }
    cout << "Переменная = " << value;
}

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    try
    {
        FooThrow(-55);
    }
    //хотим поймать целое число
    //catch (const int ex)
    //можем бросить строчку через указатель
    //catch (const char* ex)
    catch (const exception& ex)
    {
        cout << "Мы поймали " << ex.what() << endl;
    }

    return 0;
}
```

## Несколько блоков catch. Обработка исключений 

Первый соотвестувующий тип данных примет catch 

```cpp

void FooThrow(int value)
{
    //можем передать число, строку, класс
    if (value < 0)
    {
        //если бросить throw, и не поймать его будет ошибка
        //throw value;
        //throw "Число меньше 0";
        //более универсальное решение через класс exception
        //throw exception("Число меньше 0");

        throw "число меньше 0";
    }
    if (value == 0)
    {
        throw exception("Число равно 0");
    }

    if (value == 1)
    {
        throw 1;
    }

    cout << "Переменная = " << value;
}

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    try
    {
        FooThrow(1);
    }
    //хотим поймать целое число
    //catch (const int ex)
    //можем бросить строчку через указатель
    //catch (const char* ex)
    catch (const exception& ex)
    {
        cout << "Блок 1, Мы поймали " << ex.what() << endl;
    }
    catch (const char* ex)
    {
        cout << "Блок 2, Мы поймали " << ex << endl;
    }

    //если какой то странный класс приходит
    //поймаем все что угодно, нам все равно что оно бросило
    //знаем что возникла исключительная ситуация, но не знаем что произошло 
    //мы должны писать в конце всех исключений, иначе перекроет все остальные 
    catch (...)
    {
        cout << "Что то пошло не так!" << endl;
    }

        return 0;
}
```

## Свой класс exception. Свой собственный класс исключений 

```cpp
//наследник от класса exception
class MyException : public exception
{
public:
    //вызываем констурктор по умолчанию в который передаем сообщение,
    //затем это сообщение передаем в констурктор по умолчанию в класс exception
    MyException(const char* msg, int dataState)
        : exception(msg)
    {
        this->dataState = dataState;
    }

    int GetDataState() { return dataState; }

private:
    int dataState;
};

void FooThrow(int value)
{
    //можем передать число, строку, класс
    if (value < 0)
    {
        throw exception("Число меньше 0");
    }

    if (value == 1)
    {
        throw MyException("Число равно 1", value);
    }

    cout << "Переменная = " << value;
}

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    try
    {
        FooThrow(1);
    }
 

    catch (MyException& ex)
    {
        cout << "Блок 1, Мы поймали " << ex.what() << endl;
        cout << "Состояние данных " << ex.GetDataState() << endl;
    }

    //если мы ловим одинаквые, то для логики он будет равноценным
    //поэтому нужно узко специализрованные catch ставить выше 
    catch (exception& ex)
    {
        cout << "Блок 1, Мы поймали " << ex.what() << endl;
    }
    return 0;
}
```


## Ключевое слово enum, c++ 

Перечисляемый тип 

```cpp
class PC
{
public:
    //различные состояния, это набор констант поэтому с большой
    //Скорее всего больше нигде этот енум использоваться не будет, поэтому мы можем засунуть его сюда 
    enum PCState
    {
        OFF,
        ON,
        SLEEP
    };

    PCState GetState()
    {
        return State;
    }

    void SetState(PCState State)
    {
        this->State = State;
    }

private:
    PCState State;
};


//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    //что бы не удерживать много информации о различных состояних в цифрах
    //в коде появляются магические числа разные
    //присваиваем состояние, вместо слов там числа на машинном языке,
    //но мы можем работать с текстом

    PC pc;
    pc.SetState(PC::PCState::SLEEP);

    //if (pc.GetState() == PCState::ON)
    //{
    //    cout << "PC работает!" << endl;
    //}

    //можно работать с switch 
    switch (pc.GetState())
    {
    case PC::PCState::OFF:
        cout << "Выключен!" << endl;
        break;

    case PC::PCState::ON:
        cout << "Работает!" << endl;
        break;

    case PC::PCState::SLEEP:
        cout << "Спит!" << endl;
        break;
    }

    return 0;
}
```

Один enum может хранить набор констант, которые будут лежать в одном месте 

```cpp
//можно присвоить, тогда вместо стандартных значений 0, 1, 2 будут новые 
enum Speed
{
    MIN = 150,
    RECOMEND = 600,
    MAX = 800
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    Speed sp = Speed::MAX;
    cout << sp << endl;

    return 0;
}
```

800

## Пространство имен С++. namespace C++ 

Если в работе в команде, будут названы функции одинаковыми именами можно использовать пространство имен. 

Вне пространства имен функции не будут видны 

```cpp
//позволяет использовать все функции и методы лежащие в пространстве имен 
//не указывая впереди название пространства 
//но это указывать нужно только когда уверены, что не будет конфликтов 
using namespace std;
```

![[Pasted image 20250503022432.png]]

В пространство имен мы можем добавлять переменные, классы 

```cpp
namespace FirstNS
{
    void FooName()
    {
        cout << "FooName FirstNS" << endl;
    }
    int b;

    //два одинаковых класса 
    //но если один класс будет написан в глобальном пространстве имен, то будет ошибка и здесь он будет брать его 
    //так что тогда надо из глобального класса имен поместить в другое пространство имен 
    class TestName1(){};

    } // namespace FirstNS

//одно пространство имен лежит в другом пространстве имен 
//Если один раз создали один тот же пространство имен, есть возможность такая 
namespace ThirdNS
{
    namespace SecondNS
    {
        void FooName()
        {
            cout << "FooName SecondNS" << endl;
        }

         //два одинаковых класса 
        class TestName1(){};

        } // namespace SecondNS
} // namespace ThirdNS

//позволяет использовать все функции и методы лежащие в пространстве имен 
//не указывая впереди название пространства 
//но это указывать нужно только когда уверены, что не будет конфликтов 
using namespace std;

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    //мы должны указывать пространство имен откуда берем функцию
    //иначе мы берем функцию из глобального пространство имен
    ThirdNS::SecondNS::FooName();
    FirstNS::FooName();

    //std - это пространство имен со всеми станадартными функциями c++ 
    std::cout << "test";
    FirstNS::TestName1;
    ThirdNS::SecondNS::TestName1;

    return 0;
}
```

## Шаблоны классов. 

Что бы работали с разными типами данных 

```cpp
//шаблон класса, T - название обощенного типа данных, обычно принятно так, T1, T2... 
template  <typename T1, typename T2>
class MyClassTypename
{
public:
    MyClassTypename(T1 value, T2 value2)
    {
        this->value = value;
        this->value2 = value2;
    }

    //будет получать количество занимамых байт в памяти 
    void DataTypeSize()
    {
        cout << "Value" << sizeof(value) << endl;
        cout << "Value2" << sizeof(value2) << endl;
    }

    T1 Foo() { return value;  }

private:
    //принимает переменную типа T, любой тип данных
    //так же принимает пользовательские типы данных
    T1 value;
    T2 value2;
};



//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    Point a;
    int b = 2;

    //int a = 5;
    //везде T будет int 
    //MyClassTypename<int> c(a);


    //указываем T1, T2
    MyClassTypename<Point, int> c(a, b);
    c.DataTypeSize();

    //int b = c.Foo();

    return 0;
}
```

Будет 12, так как 3 переменные типа int по 4 байта. x, y, z

```cpp
    MyClassTypename<Point> c(a);
    c.DataTypeSize();
```

можно так же указывать class вместо template 

```cpp
//шаблон класса, T - название обощенного типа данных, обычно принятно так, T1, T2... 
template  <class T1>
class MyClassTypename
{
public:
    MyClassTypename(T1 value)
    {
        this->value = value;
    }

    //будет получать количество занимамых байт в памяти 
    void DataTypeSize()
    {
        cout << "Value" << sizeof(value) << endl;
    }

private:
    //принимает переменную типа T, любой тип данных
    //так же принимает пользовательские типы данных
    T1 value;
};
```

## Наследование шаблонных классов

![[Pasted image 20250503172126.png]]

```cpp
//шаблон класса, T - название обощенного типа данных, обычно принятно так, T1, T2... 
template  <class T1>
class TypeSize
{
public:
    TypeSize(T1 value)
    {
        this->value = value;
    }

    //будет получать количество занимамых байт в памяти 
    void DataTypeSize()
    {
        cout << "Value: " << sizeof(value) << endl;
    }

protected:
    //принимает переменную типа T, любой тип данных
    //так же принимает пользовательские типы данных
    T1 value;
};

//наслденик шаблонного класса 
template <class T1>
class TypeInfo : public TypeSize<T1>
{
public:
    TypeInfo(T1 value)
        : TypeSize <T1> (value)
    {
    }

    void ShowTypeName()
    {
        //выводит имя типа переменной
        //если не видит 
        //#includ <typeinfo>
        cout << "Название типа: " << typeid(this->value).name() << endl;
    }
};


//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    Point b;

    double a = 2;

    //int a = 5;
    //везде T будет int 
    //MyClassTypename<int> c(a);


    //указываем T1, T2
    TypeInfo<Point> c(b);
    c.DataTypeSize();
    c.ShowTypeName();

    //int b = c.Foo();

    return 0;
}
```

Value: 12
Название типа: class Point

## Специализация шаблона класса 

```cpp
template <typename T>
class PrinterTemplate
{
public:
    void Print(T value)
    {
        cout << value << endl;
    }
};

//специализация шаблона для класса, для работы с конкретным типом данных
//такой класс, она создает сама, но если мы указываем, она будет использовать его 
template <>
class PrinterTemplate <string>
{
    //теперь здесь нужно указавать какие методы для этого типа будут использоваться 
    //иначе при их использовании будет ошибка
public:
    void Print(string value)
    {
        //особенности вывода для класса string
        cout << "_____" << value << "_____" << endl;
    }
};


//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    //не забывать что бы для темплейтов указывать тип с которым он должен работать 
    PrinterTemplate <char> p;
    p.Print('#');

    PrinterTemplate<string> k;
    k.Print("Hello");

    return 0;
}
```

## Структуры. struct. Разница между struct и класса

Те же особенности как и класса 

```cpp
//Структуры
//Практически не отличаются от классов

class MyClassTest
{
    //по умолчанию все поля private
    //при наследовании все поля и методы private

    int a = 10;

public:
    void Print()
    {
        cout << a << endl;
    }
};

struct MyStructTest
{
    //по умолчанию все поля public
    //при наследовании все поля и методы public

    int a = 22;

//можем указать доступ к методам и переменным
private:
    void Print()
    {
        cout << a << endl;
    }

    //Так же есть констукторы и деструкторы
    MyStructTest()
    {
    }

    ~MyStructTest()
    {
    }
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    MyClassTest m;
    MyStructTest ms;

    //не увидим, переменной
    m.Print();

    ms.a = 5;

    return 0;
}
```

```cpp
class MyClassTest
{
    //по умолчанию все поля private
    //при наследовании все поля и методы private

public:
    int a = 10;
};

//если мы не укажем public, то все поля меняю свои доступ на private
//class MyClass2 : public MyClassTest
class MyClass2 : MyClassTest
{
};

struct MyStructTest
{
    //по умолчанию все поля public
    //при наследовании все поля и методы public

    int a = 22;
};

//без указания все поля будут public
struct MyStruct2 : MyStructTest
{

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    MyClassTest m;
    MyStructTest ms;

    MyClass2 m2;
    MyStruct2 ms2;

    ms2.a;

    return 0;
}
```

## Умные указатели 

```cpp
//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    //выделение данных где то, что бы брать эти данные нам нужен указатель,
    //который будет указывать где лежат эти данные
    int* ptr = new int(5);

    //разъименовывание класса, получение данных
    cout << *ptr << endl;

    delete ptr;

    return 0;
}
```

```cpp
//Умные указатели
//Класс SmartPointer будут оболочкой для нашего указателя,
//это умный указатель имитирующий сборщик мусора
//на протяжении всей жизни класса будет указывать на область памяти где лежат данные
//когда будет уничтожаться объект, значит и данные будут не нужны, затем будет вызываться деструктор
//а вместе и с деструкторм и оператор delete
template <typename T>
class SmartPointer
{
public:
    SmartPointer(T* ptr)
    {
        this->ptr = ptr;
        cout << "Constructor" << endl;
    }

    ~SmartPointer()
    {
        //очищение памяти всегда при выходе из класса
        delete ptr;
        cout << "Destructor" << endl;

    }

    //возвращаем ссылку на T, что бы получить копию данных, иначе мы создадим новые, а не изменим старые 
    T& operator*()
    {
        //вернуть разъименованный указатель
        return *ptr;
    }


private:
    //указатель на любой тип
    T* ptr;
};

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    //создание умного указателя
    //теперь не нужно заботиться о уничтожении указателя 
    SmartPointer<int> pointer = new int(5);

    *pointer = 15151;

    cout << *pointer << endl;

    return 0;
}
```

## auto_ptr | unique_ptr | shared_ptr, умные указатели 

Для работы необходимо подключить 

```cpp
#include <memory>
```

оба объекта считают, что данные принадлежат им. И когда второй смартпоинтер будет очищаться, появится ошибка

![[Pasted image 20250503205025.png]]

В момент передачи, данные затираются у одного и передаются другому 

![[Pasted image 20250503205444.png]]

```cpp
    //можно использовать вот так, но не решает проблему, 
    //если нам нужны две переменные
    //использующие адрес на память 
    auto_ptr<int> ap1(new int(5));
    auto_ptr<int> ap2(ap1);
```

```cpp
    //мы просто не может передать одни данные в другое 
    unique_ptr<int> p1(new int(5));
    unique_ptr<int> p2;
    
    //передвигает данные от одного указателя к другому
    p2 = move(p1);

    //меняет местами 
    p2.swap(p1);

    //вытянем обычный указатель, обыкновенного типа 
    int *p = p1.get();
```

```cpp
    int* p = new int(5);
    
	//затирает данные которые указаны 
    p1.reset();

    //указатель забывает о них, но данные остаются 
    p1.release();
```

С помощью shared point мы можем владить одним и тем же объектов в динмической памяти без проблем

Каждый раз когда создается объект с указателем на данные, счетчик шейред поинтов увеличивается на 1 

В деструкторе shared point есть проверка, сколько ссылок осталось на эти данные. Удаляется 1 из счетчика, когда последний объект удаляется, счетчик равен 0, уничтожаются и данные.

Это самый популярный и самый умный из умных указателей.

```cpp
    //такой тип может хранить много указателей 
    shared_ptr<int> p1(new int(5));

    shared_ptr<int> p2(p1);
```

![[Pasted image 20250503210905.png]]

## Динамический массив и умные указатели 

```cpp
#include <memory>

//Основной код
int main()
{
    setlocale(LC_ALL, "ru");

    int SIZE;
    cin >> SIZE;

    //объявить может вот так или
    //int* arr = new int[SIZE]{1, 6, 44, 9, 8};

    //будет знать что работаем именно с массивом, иначе не сможем работать с ячейками [i]
    //shared_ptr<int[]>
    //переменная типа указатель shared point хранит в себе адрес на динамический массив 
    shared_ptr<int[]> ptr(new int[SIZE]{1, 6, 44, 9, 8});

    for (int i = 0; i < SIZE; i++)
    {
        ptr[i] = rand() % 10;

        //так как shared_ptr это кастомный класс, в нем существуют перегрузки операторов 
        //поэтому мы можем выводить по элементо массив
        cout << ptr[i] << endl;
    }

    return 0;
}

```

## Реализация односвязного списка 

